<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PC-Troubleshooter v2.4</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="wrap hub-view" id="hubView">
    <header class="hub-header">
      <div class="title">PC-Troubleshooter <span class="badge" id="hubVerTag">v2.4</span></div>
      <div class="hub-info" id="hubInfo"></div>
    </header>
    <section class="hub-card" aria-labelledby="hubTitle">
      <div class="inner">
        <!--<h2 id="hubTitle"></h2>
        <p class="hint"></p>-->
        <div class="hub-grid" id="scenarioList" aria-live="polite"></div>
      </div>
    </section>
  </div>

  <div class="wrap hidden" id="scenarioView">
    <header>
      <div class="title">PC-Troubleshooter <span class="badge" id="verTag">v2.4</span></div>
      <div class="controls">
        <div class="badge" id="levelTag" aria-live="polite">Fall 1/4 • <b>Einfach</b></div>
        <button class="btn" type="button" id="scoreBtn" title="Score anzeigen" aria-label="Score anzeigen">🏆 Score</button>
        <button class="btn" type="button" id="hubBtn" title="Zurück zum Hub" aria-label="Zurück zum Hub">🏠 Hub</button>
      </div>
    </header>

    <!-- Modal/Message area shown above the story -->
    <div class="action-message" id="actionMessageTop" aria-hidden="true">
      <header class="mhead">
        <h3 id="messageTitleTop">Aktion</h3>
      </header>
      <div class="mbody" id="messageBodyTop"></div>
      <div class="mfoot">
        <button class="btn primary" id="messageOkTop">Schliessen</button>
      </div>
    </div>

    <!-- Single card: story, actions & info -->
    <section class="card story" aria-labelledby="storyTitle">
      <div class="inner">
          <h2 id="storyTitle">Szenario: Der PC, der nicht starten will</h2>
          <p id="storyText">
            Du sitzt im Informatikraum und dein PC reagiert nicht: Du drückst den Power‑Knopf, aber es passiert nichts.
            Dein Ziel: In möglichst <b>wenigen Schritten</b> die Ursache finden.
          </p>

          <figure class="scene" role="img" aria-label="PC-Tower und Monitor auf einem Schreibtisch (neutrale Ausgangslage)">
            <svg viewBox="0 0 800 220" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <!-- Tischlinie -->
              <rect x="20" y="194" width="760" height="8" rx="4" class="mutfill"/>
              <rect x="20" y="194" width="760" height="8" rx="4" class="mut" fill="none"/>

              <rect x="70" y="85" width="110" height="110" rx="8" class="mut" fill="none"/>
              <circle cx="100" cy="105" r="6" class="mut led" fill="none"/>

              <!-- Monitor -->
              <rect x="240" y="12" width="270" height="160" rx="6" class="mut" fill="none"/>
              <rect x="240" y="12" width="270" height="160" rx="6" class="mutfill screen"/>
              <rect x="370" y="173" width="10" height="19" class="mut" fill="none"/>
              <rect x="335" y="190" width="80" height="6" rx="3" class="mut" fill="none"/>
              <g class="no-signal" aria-hidden="true">
                <rect x="240" y="12" width="270" height="160" rx="6" fill="none"/>
                <text x="375" y="92" font-size="24" text-anchor="middle" style="fill:rgba(229,231,235,.88);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;letter-spacing:2px">NO SIGNAL</text>
              </g>
              <g class="booterr" aria-hidden="true">
                <rect x="240" y="12" width="270" height="160" rx="6" fill="none"/>
                <text x="375" y="92" font-size="22" text-anchor="middle" style="fill:rgba(229,231,235,.9);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;letter-spacing:1.4px">NO BOOTABLE DEVICE</text>
              </g>
              <g class="bootmenu" aria-hidden="true">
                <rect x="265" y="32" width="220" height="120" rx="10" class="bootmenu-bg"/>
                <text x="375" y="58" font-size="16" text-anchor="middle" style="fill:rgba(229,231,235,.92);font-weight:600;letter-spacing:1px">BOOT MENU</text>
                <text x="290" y="82" font-size="13" style="fill:rgba(229,231,235,.88);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;">▶ SSD (Windows)</text>
                <text x="290" y="104" font-size="13" style="fill:rgba(229,231,235,.65);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;">  USB Device</text>
                <text x="290" y="126" font-size="13" style="fill:rgba(229,231,235,.65);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;">  Network Boot</text>
                <text x="375" y="148" font-size="11" text-anchor="middle" style="fill:rgba(229,231,235,.5);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;">ENTER = Start · ESC = Zurück</text>
              </g>
              <g class="login" aria-hidden="true">
                <!-- Größeres, gut lesbares Login-Overlay, mittig im Monitor (270×160) -->
                <rect x="290" y="47" width="170" height="90" rx="8" class="mut" fill="none"/>
                <text x="375" y="80" font-size="32" text-anchor="middle" style="fill:rgba(229,231,235,.95);font-weight:700">Login</text>
                <rect x="310" y="96" width="130" height="12" rx="6" class="mut" fill="none"/>
                <rect x="310" y="118" width="130" height="12" rx="6" class="mut" fill="none"/>
              </g>
            </svg>
          </figure>

          <div class="statusbar" aria-live="polite">
            <div class="chip">Zeit: <strong id="time">0</strong> Min</div>
            <div class="chip">Schritte: <strong id="tries">0</strong></div>
            <div class="chip">Status: <strong id="status">Unbekannt</strong></div>
            
          </div>

          <div class="actions" id="actions" aria-label="Verfügbare Aktionen"></div>
          <div class="action-message" id="actionMessage" aria-hidden="true">
            <header class="mhead">
              <h3 id="messageTitle">Aktion</h3>
            </header>
            <div class="mbody" id="messageBody"></div>
            <div class="mfoot">
              <button class="btn primary" id="messageOk">Schliessen</button>
            </div>
          </div>
          <div class="legend" aria-hidden="true">Tasten: [1–6] Aktionen · [R] Neustart</div>

          <div class="footer">
            <button class="btn" id="resetBtn" title="Szenario zurücksetzen (R)" aria-keyshortcuts="R">Neustart</button>
            <button class="btn" id="hint1Btn">Hinweis</button>
            <button class="btn" id="goalBtn">Ziel</button>
          </div>

          <div class="feedback" aria-live="polite">
            <p class="msg" id="feedbackMsg">Wähle deinen ersten Schritt.</p>
            <ol class="step-log" id="stepLog" aria-label="Protokoll deiner Schritte"></ol>
          </div>

          <hr class="divider" aria-hidden="true" />

          <div class="summary" id="summary">
            <h3>Auswertung</h3>
            <p class="hint" id="resultText"></p>
            <div class="score">
              <span class="dot" id="rankDot" aria-hidden="true"></span>
              <span id="rankText">Bewertung: —</span>
            </div>
            <div class="hint" id="bestRow" style="display:none;margin-top:8px">Bestleistung: <b id="bestText">—</b></div>
          </div>
        </div>
    </section>
  </div>

  <script type="module">
    import scenario1 from './scenario1.js';
    import scenario2 from './scenario2.js';
    import scenario3 from './scenario3.js';
    import scenario4 from './scenario4.js';
    const levels = [scenario1, scenario2, scenario3, scenario4];
    // --- Persistence ---
    const STORAGE_KEY = 'pctrouble_best_v2';
    const SCORES_KEY = 'pctrouble_scores_v2';
    const PROGRESS_KEY = 'pctrouble_progress_v1';
    function loadBest(){
      try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null'); }catch{ return null; }
    }
    function saveBest(best){
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(best)); }catch{}
    }
    function loadScores(){
      try{ return JSON.parse(localStorage.getItem(SCORES_KEY) || '{}'); }catch{ return {}; }
    }
    function saveScores(scores){
      try{ localStorage.setItem(SCORES_KEY, JSON.stringify(scores)); }catch{}
    }
    function defaultProgress(){
      const unlocked = {};
      if(levels.length){ unlocked[levels[0].id] = true; }
      return { unlocked, completed: {} };
    }
    function normalizeProgress(raw){
      const base = defaultProgress();
      if(raw && typeof raw === 'object'){
        if(raw.unlocked && typeof raw.unlocked === 'object'){
          for(const key of Object.keys(raw.unlocked)){
            if(raw.unlocked[key]) base.unlocked[key] = true;
          }
        }
        if(raw.completed && typeof raw.completed === 'object'){
          for(const key of Object.keys(raw.completed)){
            if(raw.completed[key]) base.completed[key] = true;
          }
        }
      }
      try{
        const scores = loadScores();
        levels.forEach((level, idx) => {
          if(scores && scores[level.id]){
            base.unlocked[level.id] = true;
            base.completed[level.id] = true;
            const next = levels[idx + 1];
            if(next){ base.unlocked[next.id] = true; }
          }
        });
      }catch(e){}
      return base;
    }
    function loadProgress(){
      try{
        const stored = localStorage.getItem(PROGRESS_KEY);
        if(!stored) return defaultProgress();
        return normalizeProgress(JSON.parse(stored));
      }catch{ return defaultProgress(); }
    }
    function saveProgress(data){
      try{ localStorage.setItem(PROGRESS_KEY, JSON.stringify(data)); }catch{}
    }

    // --- State ---
    const state = {
      levelIdx: 0,
      actions: [],
      performed: {},
      currentActionId: null,
      activeSet: 'A',
      bootMenuOpen: false,
      bootError: false,
      usbPresent: true,
      bootOrderChanged: false,
      bootOrderPersisted: false,
      actionSequence: [],
      s4SolvedBy: null,
      s4RemovedUsb: false,
      s4UsedBootMenu: false,
      s4ChangedBootOrder: false
    };
    let progress = loadProgress();
    progress = normalizeProgress(progress);

    function isLevelUnlocked(idx){
      const level = levels[idx];
      if(!level) return false;
      progress = normalizeProgress(progress);
      return !!progress.unlocked[level.id];
    }
    function isLevelCompleted(idx){
      const level = levels[idx];
      if(!level) return false;
      progress = normalizeProgress(progress);
      return !!progress.completed[level.id];
    }
    function updateProgressAfterCompletion(idx){
      const level = levels[idx];
      if(!level) return;
      progress = normalizeProgress(progress);
      progress.unlocked[level.id] = true;
      progress.completed[level.id] = true;
      const next = levels[idx + 1];
      if(next){ progress.unlocked[next.id] = true; }
      saveProgress(progress);
    }
    function unlockedCount(){
      progress = normalizeProgress(progress);
      return levels.reduce((sum, level) => sum + (progress.unlocked[level.id] ? 1 : 0), 0);
    }
    function completedCount(){
      progress = normalizeProgress(progress);
      return levels.reduce((sum, level) => sum + (progress.completed[level.id] ? 1 : 0), 0);
    }
    function findFirstUnlockedIndex(){
      progress = normalizeProgress(progress);
      for(let i=0;i<levels.length;i++){
        if(isLevelUnlocked(i)) return i;
      }
      return 0;
    }
    function findUnlockedIndex(startIdx, direction){
      progress = normalizeProgress(progress);
      if(!levels.length) return startIdx;
      let idx = startIdx;
      for(let i=0;i<levels.length;i++){
        idx = (idx + direction + levels.length) % levels.length;
        if(isLevelUnlocked(idx)) return idx;
      }
      return startIdx;
    }

    // --- DOM helpers ---
    const $ = sel => document.querySelector(sel);
    const timeEl = $('#time');
    const triesEl = $('#tries');
    const statusEl = $('#status');
    const actionsEl = $('#actions');
    const feedbackEl = $('#feedbackMsg');
    const stepLogEl = $('#stepLog');
    const summary = $('#summary');
    const resultText = $('#resultText');
    const rankText = $('#rankText');
    const rankDot = $('#rankDot');
    const bestRow = $('#bestRow');
    const bestText = $('#bestText');
    const hubView = document.getElementById('hubView');
    const scenarioView = document.getElementById('scenarioView');
    const scenarioListEl = document.getElementById('scenarioList');
    const hubInfoEl = document.getElementById('hubInfo');
    const hubBtn = document.getElementById('hubBtn');
    const scoreBtn = document.getElementById('scoreBtn');
    const hint1Btn = document.getElementById('hint1Btn');
    const goalBtn = document.getElementById('goalBtn');
    let scenarioActive = false;

    function createMedalBadge(rank){
      const span = document.createElement('span');
      span.className = 'hub-medal';
      let text = '—';
      let variant = 'none';
      if(rank === 'Gold'){ text = '🥇 Gold'; variant = 'gold'; }
      else if(rank === 'Silber'){ text = '🥈 Silber'; variant = 'silver'; }
      else if(rank === 'Bronze'){ text = '🥉 Bronze'; variant = 'bronze'; }
      span.classList.add(variant);
      span.textContent = text;
      span.setAttribute('aria-label', `Abzeichen: ${rank || 'keines'}`);
      return span;
    }

    function renderHub(){
      if(!scenarioListEl) return;
      progress = normalizeProgress(progress);
      const scores = loadScores();
      scenarioListEl.innerHTML = '';
      const baseEntries = levels.map((level, idx) => ({
        type: 'scenario',
        level,
        index: idx,
        number: idx + 1
      }));
      const placeholders = [
        { type: 'placeholder', id: 'PLACEHOLDER_5', name: 'PLACEHOLDER_5', number: baseEntries.length + 1 },
        { type: 'placeholder', id: 'PLACEHOLDER_6', name: 'PLACEHOLDER_6', number: baseEntries.length + 2 }
      ];
      const entries = baseEntries.concat(placeholders);
      entries.forEach(entry => {
        const item = document.createElement('article');
        item.className = 'hub-item';
        const header = document.createElement('div');
        header.className = 'hub-item-header';
        const label = document.createElement('span');
        label.className = 'hub-item-label';
        label.textContent = `Szenario ${entry.number}`;
        header.appendChild(label);
        const rank = entry.type === 'scenario' ? (scores[entry.level.id]?.rank || null) : null;
        header.appendChild(createMedalBadge(rank));
        item.appendChild(header);

        const title = document.createElement('h3');
        title.textContent = entry.type === 'scenario' ? entry.level.name : entry.name;
        item.appendChild(title);

        if(entry.type === 'placeholder'){
          item.classList.add('placeholder');
          const status = document.createElement('p');
          status.className = 'hub-status';
          status.textContent = 'Bald verfügbar';
          item.appendChild(status);
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn';
          btn.disabled = true;
          btn.textContent = 'In Arbeit';
          item.appendChild(btn);
          scenarioListEl.appendChild(item);
          return;
        }

        const unlocked = isLevelUnlocked(entry.index);
        const completed = isLevelCompleted(entry.index);
        if(!unlocked){ item.classList.add('locked'); }
        if(completed){ item.classList.add('completed'); }

        const status = document.createElement('p');
        status.className = 'hub-status';
        if(unlocked){
          status.textContent = completed ? 'Status: Abgeschlossen' : 'Status: Freigeschaltet';
        } else {
          const req = entry.number > 1 ? ` – Schließe Szenario ${entry.number - 1} ab.` : '';
          status.innerHTML = `Status: <span class="hub-lock">🔒 Gesperrt</span>${req}`;
        }
        item.appendChild(status);

        const best = document.createElement('p');
        best.className = 'hub-best';
        const score = scores[entry.level.id];
        if(score){
          const rankLabel = score.rank || '—';
          const timeLabel = typeof score.time === 'number' ? `${score.time} Min` : '— Min';
          const triesLabel = typeof score.tries === 'number' ? `${score.tries} Schritte` : '— Schritte';
          best.innerHTML = `Bestes Ergebnis: <b>${rankLabel}</b> · ${timeLabel} / ${triesLabel}`;
        } else {
          best.textContent = 'Noch keine Medaille.';
        }
        item.appendChild(best);

        const btn = document.createElement('button');
        btn.type = 'button';
        if(unlocked){
          btn.className = 'btn primary';
          btn.textContent = 'Starten';
          btn.addEventListener('click', () => startScenario(entry.index));
        } else {
          btn.className = 'btn';
          btn.disabled = true;
          btn.textContent = '🔒 Gesperrt';
        }
        item.appendChild(btn);

        scenarioListEl.appendChild(item);
      });

      if(hubInfoEl){
        hubInfoEl.innerHTML = '';
        const completedBadge = document.createElement('span');
        completedBadge.className = 'badge';
        completedBadge.textContent = `Abgeschlossen: ${completedCount()}/${levels.length}`;
        hubInfoEl.appendChild(completedBadge);
        const unlockedBadge = document.createElement('span');
        unlockedBadge.className = 'badge';
        unlockedBadge.textContent = `Freigeschaltet: ${unlockedCount()}/${levels.length}`;
        hubInfoEl.appendChild(unlockedBadge);
      }
    }

    function showHub(){
      progress = normalizeProgress(progress);
      saveProgress(progress);
      if(hubView) hubView.classList.remove('hidden');
      if(scenarioView) scenarioView.classList.add('hidden');
      scenarioActive = false;
      renderHub();
      if(document.body){ document.body.classList.add('hub-active'); }
    }

    function startScenario(idx){
      if(!isLevelUnlocked(idx)) return;
      if(hubView) hubView.classList.add('hidden');
      if(scenarioView) scenarioView.classList.remove('hidden');
      if(document.body){ document.body.classList.remove('hub-active'); }
      scenarioActive = true;
      try{ if(topModalEl && topModalEl.classList.contains('open')) closeTopModal(); }catch(e){}
      try{ if(modalOpen) closeModal(); }catch(e){}
      hideCelebration();
      loadLevel(idx);
      const firstAction = actionsEl ? actionsEl.querySelector('button.action') : null;
      if(firstAction) firstAction.focus();
    }

    function returnToHub(options = {}){
      const fromModal = options.fromModal === true;
      if(!fromModal){
        try{ if(modalOpen) closeModal(); }catch(e){}
      }
      try{ if(topModalEl && topModalEl.classList.contains('open')) closeTopModal(); }catch(e){}
      hideCelebration();
      showHub();
      const focusTarget = scenarioListEl && scenarioListEl.querySelector('button:not([disabled])');
      if(focusTarget) focusTarget.focus();
    }

    const hint1Html = 'Was kannst du prüfen, <b>ohne den PC zu öffnen</b>?';
    const hint2Html = `<ul class="hint"><li><b>Stromversorgung:</b> Steckdosenleiste an? Netzkabel fest am PC und an der Leiste/Steckdose? Netzteil‑Schalter (I/O) auf <b>I</b> (falls vorhanden)?</li><li><b>Anzeige/Signal:</b> Monitor eingeschaltet? Richtigen Eingang (HDMI/DP) gewählt? Kabel steckt fest? Falls möglich, anderen Port/Kabel testen.</li><li>Wenn der PC weiterhin <i>gar nicht</i> reagiert, wären interne Ursachen der nächste Schritt – in diesem Level bleiben wir bei externen Checks.</li></ul>`;
    const goalHtml = `<ul class="hint"><li><b>Du übst:</b> strukturiert Fehler finden (erst extern, dann intern), Entscheidungen begründen und deine Schritte protokollieren.</li><li><b>LP21:</b> MI 3.3 «Fehler systematisch suchen &amp; beheben», MI 2.2 «Geräte zweckmässig einsetzen» — genau das trainierst du hier im Szenario.</li><li><b>Tipps fürs Szenario:</b> formuliere deine Vermutung laut, notiere jeden Schritt (Zeit/Schritte siehst du links) und vergleiche danach mit deiner Bestleistung.</li></ul>`;

    // Message helpers
    let modalOpen = false, lastFocusEl = null;
    // Default in-card modal for actions/hints
    const modalEl = document.getElementById('actionMessage');
    const modalTitleEl = document.getElementById('messageTitle');
    const modalBodyEl = document.getElementById('messageBody');
    const modalOkEl = document.getElementById('messageOk');
    // Top score modal elements (only used for Score)
    const topModalEl = document.getElementById('actionMessageTop');
    const topModalTitleEl = document.getElementById('messageTitleTop');
    const topModalBodyEl = document.getElementById('messageBodyTop');
    const topModalOkEl = document.getElementById('messageOkTop');
    let celebrationEl = null;
    let celebrationTimer = null;
    // Track which hotkey opened the modal (if any)
    let lastHotkey = null;
    let modalOpenKey = null;
    function openModal({title='Hinweis', html='', okLabel='Schliessen'}){
      if(!modalEl) return;
      modalOpen = true;
      actionsEl.style.display = 'none';
      modalTitleEl.textContent = title;
      // Inject Auswertung into the completion modal
      if(title === 'Aufgabe abgeschlossen'){
        modalEl.classList.add('completion');
        // Show evaluation; completion must be triggered explicitly elsewhere
        const evalHtml = typeof buildEvaluationHtml === 'function' ? buildEvaluationHtml() : '';
        const intro = (typeof completionIntroHtml === 'function') ? completionIntroHtml() : html;
        modalBodyEl.innerHTML = intro + evalHtml;
      } else {
        modalBodyEl.innerHTML = html;
        modalEl.classList.remove('completion');
      }
      if(modalOkEl) modalOkEl.textContent = okLabel;
      if(title === 'Aufgabe abgeschlossen' && modalOkEl){ modalOkEl.textContent = 'Zurück zum Hub'; }
      modalEl.classList.add('open');
      modalEl.setAttribute('aria-hidden','false');
      lastFocusEl = document.activeElement;
      if(modalOkEl) modalOkEl.focus();
      // remember the key that opened this modal and reset the pending one
      modalOpenKey = lastHotkey;
      lastHotkey = null;
      if(title === 'Aufgabe abgeschlossen') showCelebration();
    }
    function openTopModal({title='Score', html='', okLabel='Schliessen'}){
      if(!topModalEl) return;
      modalOpen = true;
      actionsEl.style.display = 'none';
      if(topModalTitleEl) topModalTitleEl.textContent = title;
      if(topModalBodyEl) topModalBodyEl.innerHTML = html;
      if(topModalOkEl) topModalOkEl.textContent = okLabel;
      topModalEl.classList.add('open');
      topModalEl.setAttribute('aria-hidden','false');
      lastFocusEl = document.activeElement;
      if(topModalOkEl) topModalOkEl.focus();
      modalOpenKey = lastHotkey;
      lastHotkey = null;
    }
    function closeModal(){
      if(!modalEl) return;
      modalOpen = false;
      modalEl.classList.remove('open');
      modalEl.classList.remove('completion');
      modalEl.setAttribute('aria-hidden','true');
      actionsEl.style.display = '';
      if(lastFocusEl) lastFocusEl.focus();
      hideCelebration();
      modalOpenKey = null;
    }
    function closeTopModal(){
      if(!topModalEl) return;
      modalOpen = false;
      topModalEl.classList.remove('open');
      topModalEl.setAttribute('aria-hidden','true');
      actionsEl.style.display = '';
      if(lastFocusEl) lastFocusEl.focus();
      modalOpenKey = null;
    }
    function showCelebration(){
      if(celebrationEl) return;
      if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches){ return; }
      celebrationEl = document.createElement('div');
      celebrationEl.className = 'confetti';
      const colors = ['#fbbf24','#60a5fa','#22c55e','#ef4444'];
      function spawn(n=12){
        for(let i=0;i<n;i++){
          const p = document.createElement('span');
          p.className = 'confetti-piece';
          p.style.left = Math.random()*100 + '%';
          p.style.backgroundColor = colors[i % colors.length];
          p.style.animationDelay = (Math.random()*0.8) + 's';
          p.style.animationDuration = (2 + Math.random()*2) + 's';
          p.addEventListener('animationend', ()=> p.remove());
          celebrationEl.appendChild(p);
        }
      }
      spawn(24);
      document.body.appendChild(celebrationEl);
      celebrationTimer = setInterval(()=> spawn(10), 600);
    }
    function hideCelebration(){
      if(celebrationTimer){ clearInterval(celebrationTimer); celebrationTimer = null; }
      if(celebrationEl){ celebrationEl.remove(); celebrationEl = null; }
    }
    // Transition helper: animate card out/in when switching levels
    function animateToLevel(idx){
      const card = document.querySelector('section.card.story');
      if(!card){ loadLevel(idx); return; }
      // If already animating, skip to direct load
      if(card.classList.contains('transition-out') || card.classList.contains('transition-in')){
        loadLevel(idx); return;
      }
      card.classList.add('transitioning','transition-out');
      const onOutEnd = ()=>{
        card.removeEventListener('animationend', onOutEnd);
        loadLevel(idx);
        // Next tick to ensure DOM updates before animating in
        requestAnimationFrame(()=>{
          card.classList.remove('transition-out');
          card.classList.add('transition-in');
          const onInEnd = ()=>{
            card.removeEventListener('animationend', onInEnd);
            card.classList.remove('transition-in','transitioning');
          };
          card.addEventListener('animationend', onInEnd, { once:true });
        });
      };
      card.addEventListener('animationend', onOutEnd, { once:true });
    }

    if(modalOkEl) modalOkEl.addEventListener('click', () => {
      if(modalTitleEl && modalTitleEl.textContent === 'Aufgabe abgeschlossen'){
        closeModal();
        hideCelebration();
        returnToHub({ fromModal: true });
      } else {
        closeModal();
      }
    });
    if(topModalOkEl) topModalOkEl.addEventListener('click', () => { closeTopModal(); });
    if(hubBtn) hubBtn.addEventListener('click', () => returnToHub());

    function setStatus(txt){ statusEl.textContent = txt; renderMeters(); }
    function renderMeters(){ timeEl.textContent = state.time; triesEl.textContent = state.tries; }
    function say(html){ feedbackEl.innerHTML = html; }
    function pushLog(step, note=''){
      state.log.push({step, note});
      const li = document.createElement('li');
      li.textContent = note ? `${step} (${note})` : step;
      stepLogEl.appendChild(li);
    }

    function runAction(a){
      if(!a || state.solved) return;
      state.currentActionId = a.id || null;
      if(a.id){
        if(!Array.isArray(state.actionSequence)) state.actionSequence = [];
        state.actionSequence.push(a.id);
      }
      a.effect.call(a);
      if(a.id){ state.performed[a.id] = true; }
      // If the action itself solved the scenario (e.g., Scenario 2),
      // immediately show the completion modal like Scenario 1.
      if(state.solved && !modalOpen){
        openModal({
          title: 'Aufgabe abgeschlossen',
          html: completionIntroHtml(),
          okLabel: 'Zurück zum Hub'
        });
        return;
      }
      if(checkSolvedPerScenario && checkSolvedPerScenario()) return;
      const solvedCombo = false; // old combo check disabled
        // old condition removed
        // old condition removed
        // old condition removed
      if(false){ // old combo check disabled
        finish(true, 'Stromversorgung und Monitor aktiviert.');
        openModal({
          title: 'Aufgabe abgeschlossen',
          html: completionIntroHtml(),
          okLabel: 'Zurück zum Hub'
        });
      } else if (!modalOpen){
        const html = (feedbackEl && feedbackEl.innerHTML) ? feedbackEl.innerHTML : 'Aktion ausgeführt.';
        openModal({
          title: a.label,
          html
        });
      }
    }

    function checkSolvedPerScenario(){
      const L = levels && levels[state.levelIdx];
      if(!L) return false;
      switch(L.id){
        case 'L0': {
          const hasMonitor = !!state.performed['monitor'];
          const hasPower = !!state.performed['power-cable'];
          if(!state.solved && hasMonitor && hasPower && state.monitorOn){
            finish(true, 'Stromversorgung und Monitor aktiviert.');
            openModal({ title: 'Aufgabe abgeschlossen', html: completionIntroHtml(), okLabel: 'Zurück zum Hub' });
            return true;
          }
          break;
        }
        case 'E1': {
          // Require order: first [2] monitor on, then [6] source
          const didMonitor = !!state.performed['monitor'];
          const isSourceNow = state.currentActionId === 'source';
          if(!state.solved && didMonitor && isSourceNow && state.monitorOn){
            finish(true, 'Quelle korrekt, Signal wiederhergestellt.');
            openModal({ title: 'Aufgabe abgeschlossen', html: completionIntroHtml(), okLabel: 'Zurück zum Hub' });
            return true;
          }
          break;
        }
        default:
          break;
      }
      return false;
    }

    function updateScene(){
      const scene = document.querySelector('.scene');
      if(!scene) return;
      scene.classList.remove('nosig','power-on','login','booterr','bootmenu');
      if(state.pcOn) scene.classList.add('power-on');
      const L = levels && levels[state.levelIdx];
      if(L && L.id === 'S4'){
        if(!state.monitorOn){
          return;
        }
        if(!state.bootError){
          scene.classList.add('login');
        } else if(state.activeSet === 'B'){
          scene.classList.add('bootmenu');
        } else {
          scene.classList.add('booterr');
        }
      } else {
        if(state.monitorOn && (!state.pcOn || !state.signalOk)) scene.classList.add('nosig');
        if(state.pcOn && state.monitorOn && state.signalOk) scene.classList.add('login');
      }
    }

    function renderActions(){
      actionsEl.innerHTML = '';
      const L = levels && levels[state.levelIdx];
      const isS4 = !!(L && L.id === 'S4');
      const activeSet = isS4 ? (state.activeSet || 'A') : null;
      if(isS4){
        const label = document.createElement('div');
        label.className = 'action-set-label';
        label.textContent = activeSet === 'A' ? 'Set A – Basis' : 'Set B – Setup/Boot';
        actionsEl.appendChild(label);
      }
      [...state.actions]
        .filter(a => !isS4 || !a.set || a.set === activeSet)
        .sort((a,b)=>parseInt(a.hotkey)-parseInt(b.hotkey))
        .forEach(a=>{
          const btn = document.createElement('button');
          btn.className = 'action';
          btn.type = 'button';
          btn.dataset.key = a.hotkey;
          btn.innerHTML = `<span class="label">${a.label}</span>`;
          btn.setAttribute('aria-label', a.label + ` Taste ${a.hotkey}`);
          btn.addEventListener('click', () => { lastHotkey = a.hotkey; runAction(a); });
          actionsEl.appendChild(btn);
        });
    }

    
function evalRankAndScore(t, n){
  var medal = 'Bronze';
  var long = 'Bronze - geloest, aber umstaendlich';
  var color = 'var(--bronze)';
  if (t <= 3 && n <= 2){ medal = 'Gold'; long = 'Gold - exzellent (praezise & schnell)'; color = 'var(--gold)'; }
  else if (t <= 6 && n <= 3){ medal = 'Silber'; long = 'Silber - gut & systematisch'; color = 'var(--silver)'; }
  var score = medal === 'Gold' ? 100 : (medal === 'Silber' ? 70 : 40);
  return { medal: medal, long: long, color: color, score: score };
}
function evaluateScenarioResult(){
      const t = state.time;
      const n = state.tries;
      const L = levels && levels[state.levelIdx];
      if(L && L.id === 'S4'){
        const seq = Array.isArray(state.actionSequence) ? state.actionSequence.slice() : [];
        const solvedBy = state.s4SolvedBy;
        const matches = expected => seq.length === expected.length && expected.every((id, idx) => seq[idx] === id);
        let medal = 'Bronze';
        let long = 'Bronze – Fehler behoben, aber mit Umwegen.';
        let score = 40;
        let detailText = '';
        if(solvedBy === 'temp-ssd' && matches(['boot-menu','boot-ssd'])){
          medal = 'Gold';
          long = 'Gold – Boot-Menü genutzt und temporär von der SSD gestartet.';
          score = 100;
          detailText = 'Pfad: Boot-Menü → SSD (temporär).';
        } else if(solvedBy === 'usb-restart' && matches(['remove-usb','s4-restart'])){
          medal = 'Silber';
          long = 'Silber – USB entfernt und sauber neu gestartet.';
          score = 70;
          detailText = 'Pfad: USB entfernen → Neustart.';
        } else if(solvedBy === 'bootorder-save' && matches(['boot-menu','boot-order','save-changes'])){
          medal = 'Silber';
          long = 'Silber – Bootreihenfolge korrigiert und gespeichert.';
          score = 70;
          detailText = 'Pfad: Boot-Menü → Bootreihenfolge ändern → Speichern.';
        } else if(solvedBy === 'temp-ssd'){
          long = 'Bronze – Boot-Menü genutzt, aber mit Umwegen.';
          detailText = 'Pfad: Boot-Menü / SSD mit Zusatzschritten.';
        } else if(solvedBy === 'usb-restart'){
          long = 'Bronze – USB-Lösung, aber mit Umwegen.';
          detailText = 'Pfad: USB + Neustart (Umwege).';
        } else if(solvedBy === 'bootorder-save'){
          long = 'Bronze – BIOS-Anpassung mit Umwegen.';
          detailText = 'Pfad: Bootreihenfolge angepasst (Umwege).';
        } else {
          detailText = 'Pfad: Problem behoben.';
        }
        const color = medal === 'Gold' ? 'var(--gold)' : medal === 'Silber' ? 'var(--silver)' : 'var(--bronze)';
        return { medal, long, color, score, detailText, time: t, tries: n };
      }
      const ev = evalRankAndScore(t, n);
      return { medal: ev.medal, long: ev.long, color: ev.color, score: ev.score, detailText: '', time: t, tries: n };
    }
function buildEvaluationHtml(){
      const ev = evaluateScenarioResult();
      const best = loadBest();
      const bestHtml = best ? `<div class="hint" style="margin-top:8px">Bestleistung: <b>${best.time} Min / ${best.tries} Schritte</b></div>` : '';
      const dotStyle = `background: linear-gradient(180deg, ${ev.color}, ${ev.color})`;
      const detailHtml = ev.detailText ? `<p class="hint">${ev.detailText}</p>` : '';
      return `
        <hr class="divider" aria-hidden="true" />
        <h3>AUSWERTUNG</h3>
        ${detailHtml}
        <p class="hint">Zeit: <b>${ev.time} Min</b> - Schritte: <b>${ev.tries}</b> - Punkte: <b>${ev.score}</b></p>
        <div class="score">
          <span class="dot" style="${dotStyle}" aria-hidden="true"></span>
          <span>Bewertung: ${ev.long}</span>
        </div>
        ${bestHtml}
      `;
}
function completionIntroHtml(){
  const L = levels && levels[state.levelIdx];
  if(!L) return '<p><b>Aufgabe geschafft.</b> PC und Monitor sind bereit.</p><p>Das <b>Login</b> ist sichtbar.</p>';
  switch(L.id){
    case 'L0':
      return '<p><b>Aufgabe abgeschlossen.</b> PC hat Strom, Monitor ist an, Signal liegt an.</p><p>Das <b>Login</b> ist sichtbar.</p>';
    case 'E1':
      return '<p><b>Aufgabe abgeschlossen.</b> Quelle korrekt, Signal wiederhergestellt.</p><p>Das <b>Login</b> ist sichtbar.</p>';
    case 'M3':
      return '<p><b>Aufgabe abgeschlossen.</b> POST erfolgreich, Anzeige aktiv.</p><p>Das <b>Login</b> ist sichtbar.</p>';
    case 'S4': {
      switch(state.s4SolvedBy){
        case 'temp-ssd':
          return '<p><b>Aufgabe abgeschlossen.</b> Du hast über das Boot-Menü temporär von der SSD gestartet.</p><p>Das <b>Login</b> ist sichtbar.</p>';
        case 'usb-restart':
          return '<p><b>Aufgabe abgeschlossen.</b> Störende USB-Geräte entfernt und sauber neu gestartet.</p><p>Das <b>Login</b> ist sichtbar.</p>';
        case 'bootorder-save':
          return '<p><b>Aufgabe abgeschlossen.</b> Bootreihenfolge korrigiert und gespeichert – die SSD startet wieder automatisch.</p><p>Das <b>Login</b> ist sichtbar.</p>';
        default:
          return '<p><b>Aufgabe abgeschlossen.</b> Bootfehler behoben.</p><p>Das <b>Login</b> ist sichtbar.</p>';
      }
    }
    default:
      return '<p><b>Aufgabe geschafft.</b> PC und Monitor sind bereit.</p><p>Das <b>Login</b> ist sichtbar.</p>';
  }
}
function finish(success, detail){
      // Scenario-specific guard: E1 requires order 2 then 6
      try{
        const L = levels && levels[state.levelIdx];
        if(L && L.id === 'E1'){
          const isSourceNow = state.currentActionId === 'source';
          const didMonitor = !!(state.performed && state.performed['monitor']);
          if(!(isSourceNow && didMonitor && state.monitorOn)){
            return; // block auto-finish if order not satisfied
          }
        }
      }catch(e){}
      state.solved = true;
      showCelebration();
      setStatus('Geloest');
      say(`<span class="good">Problem behoben.</span> ${detail} Der PC startet, du kannst weiterarbeiten.`);
      // Hinweis: Reset bleibt jederzeit möglich

      // Bewertung
      const evaluation = evaluateScenarioResult();
      const t = evaluation.time;
      const n = evaluation.tries;
      const level = levels[state.levelIdx];
      if(level && level.id === 'S4'){
        const parts = [];
        if(evaluation.detailText) parts.push(evaluation.detailText);
        parts.push(`Zeit: <b>${t} Min</b> - Schritte: <b>${n}</b> - Punkte: <b>${evaluation.score}</b>`);
        resultText.innerHTML = parts.join('<br/>');
      } else {
        resultText.innerHTML = 'Zeit: <b>' + t + ' Min</b> - Schritte: <b>' + n + '</b> - Punkte: <b>' + evaluation.score + '</b>';
      }
      rankText.textContent = 'Bewertung: ' + evaluation.long;
      rankDot.style.background = 'linear-gradient(180deg, ' + evaluation.color + ', ' + evaluation.color + ')';

      // Bestleistung speichern/anzeigen (besser = weniger Zeit, bei Gleichstand weniger Schritte)
      const prev = loadBest();
      const current = {time:t, tries:n};
      const better = !prev || current.time < prev.time || (current.time === prev.time && current.tries < prev.tries);
      if (better){ saveBest(current); }
      showBest();
      // Pro-Szenario-Score speichern
      const scores = loadScores();
      const prevS = level ? scores[level.id] : null;
      const shouldUpdate = !prevS || (evaluation.score > prevS.score) || (evaluation.score === prevS.score && (t < prevS.time || (t === prevS.time && n < prevS.tries)));
      if (shouldUpdate){
        if(level){
          scores[level.id] = { time: t, tries: n, rank: evaluation.medal, score: evaluation.score, updatedAt: new Date().toISOString() };
        }
        saveScores(scores);
      }
      updateProgressAfterCompletion(state.levelIdx);
      renderHub();
    }

    function animateReset(){
      try{ if(topModalEl && topModalEl.classList.contains('open')) closeTopModal(); }catch(e){}
      try{ if(modalOpen) closeModal(); }catch(e){}
      try{ hideCelebration(); }catch(e){}
      const card = document.querySelector('section.card.story');
      if(!card){ loadLevel(state.levelIdx); return; }
      if(card.classList.contains('restart-out') || card.classList.contains('restart-in')){ loadLevel(state.levelIdx); return; }
      // Overlay hint
      let ov = document.createElement('div');
      ov.className = 'restart-overlay';
      ov.innerHTML = '<div class="restart-indicator"><span class="icon">⟳</span><span>Neustart</span></div>';
      document.body.appendChild(ov);
      card.classList.add('transitioning','restart-out');
      const onOutEnd = ()=>{
        card.removeEventListener('animationend', onOutEnd);
        loadLevel(state.levelIdx);
        requestAnimationFrame(()=>{
          card.classList.remove('restart-out');
          card.classList.add('restart-in');
          const onInEnd = ()=>{
            card.removeEventListener('animationend', onInEnd);
            card.classList.remove('restart-in','transitioning');
            // remove overlay after a short delay
            setTimeout(()=>{ try{ ov.remove(); }catch(e){} }, 200);
          };
          card.addEventListener('animationend', onInEnd, { once:true });
        });
      };
      card.addEventListener('animationend', onOutEnd, { once:true });
    }

    function reset(){ animateReset(); }

    function showBest(){
      const best = loadBest();
      if(best){
        if(bestText) bestText.textContent = `${best.time} Min / ${best.tries} Schritte`;
        if(bestRow) bestRow.style.display = '';
      } else {
        if(bestRow) bestRow.style.display = 'none';
      }
    }

    // Level definitions & loader
    function makeActions(){
      return {
        // L0-only
        ram: {
          id: 'ram',
          label: '📏 Arbeitsspeicher überprüfen',
          hotkey: '1',
          delta: 6,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Intern - nicht zielfuehrend');
            pushLog(this.label, `+${this.delta} Min`);
            say('<span class="bad">Overkill / nicht symptombezogen.</span> Bei "geht nicht an" zuerst externe Checks (Strom, Monitor).');
          }
        },
        network: {
          id: 'network',
          label: '🌐 Netzwerkkabel prüfen',
          hotkey: '6',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Nicht relevant');
            pushLog(this.label, '+1 Min');
            say('<span class="warn">Kein Einfluss aufs Einschalten.</span> Nützlich bei Internet-/Anmeldeproblemen. Hier zuerst <b>Strom</b> und <b>Monitor</b> klären.');
          }
        },
        // Shared
        monitorToggle: {
          id: 'monitor',
          label: '🖥️ Monitor ein/aus',
          hotkey: '2',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            if(state.monitorOn){
              state.monitorOn = false; updateScene();
              setStatus('Monitor aus');
              pushLog(this.label, '+1 Min');
              say('<span class="warn">Monitor ausgeschaltet.</span> Schalte ihn wieder ein, wenn du bereit bist, und prüfe <b>Quelle/Kabel</b>.');
              openModal({
                title: 'Monitor ausgeschaltet',
                html: '<p>Du schaltest den Monitor aus. Das Display bleibt schwarz.</p><p>Schalte ihn wieder ein, um die Anzeige zu prüfen.</p>'
              });
            } else {
              state.monitorOn = true; updateScene();
              setStatus('Monitor an');
              pushLog(this.label, '+1 Min');
              if(state.pcOn && state.signalOk){
                say('<span class="good">Monitor eingeschaltet.</span> <b>Login</b> ist sichtbar.');
                openModal({
                  title: 'Bild vorhanden',
                  html: '<p>Der Monitor ist an und zeigt <b>Login</b>.</p><p>Gut gemacht!</p>'
                });
              } else {
                say('<span class="warn">Monitor ist an.</span> Anzeige zeigt <b>NO SIGNAL</b>. Prüfe <b>Quelle (HDMI/DP)</b> oder <b>Monitorkabel</b>.');
                openModal({
                  title: 'Monitor eingeschaltet',
                  html: '<p>Der Monitor ist an.</p><p>Es wird <b>NO SIGNAL</b> angezeigt – prüfe <b>Quelle/Kabel</b>.</p>'
                });
              }
            }
          }
        },
        bios: {
          id: 'bios',
          label: '⚙️ Direkt ins BIOS starten',
          hotkey: '3',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Nicht zielfuehrend');
            pushLog(this.label, '+1 Min');
            if(!state.pcOn){
              say(`<span class="bad">Das geht (noch) nicht.</span> Solange der PC <i>gar nicht</i> startet, kommst du nicht ins BIOS. Erst muss <b>Strom</b> anliegen.`);
            } else {
              say(`<span class="warn">Nicht zielführend.</span> Das Problem betrifft <b>Anzeige/Signal</b>, nicht das BIOS. Prüfe Monitor <b>ein/aus</b>, <b>Quelle</b> oder <b>Kabel</b>.`);
            }
          }
        },
        cpu: {
          id: 'cpu',
          label: '🧰 Prozessor ausbauen & neu einsetzen',
          hotkey: '4',
          delta: 8,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Risiko hoch');
            pushLog(this.label, '+8 Min');
            say(`<span class="bad">Overkill!</span> Das ist ein tiefer Eingriff mit Risiko. Zuerst immer die <b>einfachen</b> Dinge prüfen: Strom, Kabel, Schalter.`);
          }
        },
        power: {
          id: 'power-cable',
          label: '🔌 Stromkabel & Steckdose prüfen',
          hotkey: '5',
          delta: 2,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            const wasOn = state.pcOn;
            setStatus('Strom ok');
            pushLog(this.label, `+${this.delta} Min`);
            state.pcOn = true;
            updateScene();
            const html = wasOn
              ? '<p>Du prüfst die Stromkette – sie war bereits <b>in Ordnung</b>. Der PC hat Strom.</p><p>Falls noch kein Bild zu sehen ist: <b>Monitor einschalten</b> oder <b>Signal prüfen</b>.</p>'
              : '<p>Du verfolgst das Netzkabel bis zur Steckdose. Am Netzteil war das Kabel <b>locker</b> – du steckst es fest ein. Die PC‑LED leuchtet jetzt <b>grün</b>.</p><p>Der Monitor bleibt noch schwarz. Überlege: <b>Monitor einschalten</b> oder <b>Signal prüfen</b>?</p>';
            openModal({ title: 'Stromkette geprüft', html });
            if(state.monitorOn && state.signalOk){
              say('<span class="good">Stromversorgung hergestellt.</span> <b>Login</b> ist sichtbar.');
            } else {
              say('<span class="good">Stromversorgung hergestellt.</span> Prüfe nun die <b>Anzeige/Signal</b> (Monitor einschalten / Quelle wählen).');
            }
          }
        },
        monitorCable: {
          id: 'monitor-cable',
          label: '🔌 Monitorkabel prüfen',
          hotkey: '1',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Signal pruefen');
            pushLog(this.label, '+1 Min');
            // Szenario 2 (E1): Kabel war bereits korrekt eingesteckt -> keine Aenderung
            const cur = levels && levels[state.levelIdx];
            if(cur && cur.id === 'E1'){
              say('<span class="info">Kabel war bereits <b>korrekt eingesteckt</b>.</span> Pruefe jetzt die <b>Quelle (HDMI/DP)</b>.');
              return;
            }
            state.signalOk = true; updateScene();
            const L = levels && levels[state.levelIdx];
            if(state.pcOn && state.monitorOn){
              say('<span class="good">Kabel sitzt fest.</span> <b>Login</b> ist sichtbar.');
              if(!L || L.id !== 'E1'){
                finish(true, 'Signal wiederhergestellt.');
              }
            } else if(!state.monitorOn){
              say('<span class="warn">Kabel sitzt fest.</span> Schalte jetzt den <b>Monitor</b> ein.');
            } else {
              say('<span class="warn">Kabel sitzt fest.</span> Prüfe noch die <b>Stromversorgung</b> des PCs.');
            }
          }
        },
        source: {
          id: 'source',
          label: '🔀 Monitorquelle umschalten (HDMI/DP)',
          hotkey: '6',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Signal pruefen');
            pushLog(this.label, '+1 Min');
            // Wenn der Monitor AUS ist, kann die Quelle nicht umgeschaltet werden → erst einschalten
            if(!state.monitorOn){
              say('<span class="warn">Monitor ist aus.</span> Schalte zuerst den <b>Monitor</b> ein, dann die <b>Quelle</b> wählen.');
              return;
            }
            // Quelle korrekt → Signal ok (nur wenn Monitor an)
            state.signalOk = true; updateScene();
            if(state.pcOn){
              say('<span class="good">Quelle korrekt.</span> <b>Login</b> ist sichtbar.');
              finish(true, 'Signal wiederhergestellt.');
            } else {
              say('<span class="warn">Quelle korrekt.</span> Prüfe noch die <b>Stromversorgung</b> des PCs.');
            }
          }
        },
        ramFix: {
          id: 'ram-fix',
          label: '📏 Arbeitsspeicher (RAM) überprüfen',
          hotkey: '4',
          delta: 4,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('POST ok');
            pushLog(this.label, '+4 Min');
            state.signalOk = true; updateScene();
            if(state.pcOn && state.monitorOn){
              say('<span class="good">Arbeitsspeicher sitzt korrekt.</span> <b>Login</b> ist sichtbar.');
              finish(true, 'POST erfolgreich, Anzeige aktiv.');
            } else if(!state.monitorOn){
              say('<span class="warn">Arbeitsspeicher sitzt korrekt.</span> Schalte jetzt den <b>Monitor</b> ein.');
            } else {
              say('<span class="warn">Arbeitsspeicher sitzt korrekt.</span> Prüfe noch die <b>Stromversorgung</b>.');
            }
          }
        },
        postCheck: {
          id: 'post-check',
          label: '🔔 Pieptöne / POST‑LED prüfen',
          hotkey: '1',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Diagnose');
            pushLog(this.label, '+1 Min');
            say('<span class="good">Hinweis:</span> Die <b>DRAM‑LED</b> leuchtet / Beepcode für Speicher. <b>Arbeitsspeicher (RAM) prüfen<\/b> (korrekt einsetzen).');
          }
        },
        cmosReset: {
          id: 'cmos-reset',
          label: '🪛 CMOS‑Reset (kurz)',
          hotkey: '6',
          delta: 2,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Nicht zielfuehrend');
            pushLog(this.label, '+2 Min');
            say('<span class="warn">Hier unwahrscheinlich.</span> CMOS‑Reset hilft bei BIOS‑Fehlkonfig. Der Hinweis zeigt eher auf <b>RAM</b> (POST).');
          }
        }
      };
    }
    function makeScenario4Actions(){
      return [
        {
          id: 'remove-usb',
          set: 'A',
          label: '⏏️ USB-Sticks entfernen',
          hotkey: '1',
          delta: 1,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            const alreadyRemoved = !state.usbPresent;
            setStatus('USB geprüft');
            if(alreadyRemoved){
              say('<span class="info">Keine USB-Sticks eingesteckt.</span> Der Bootfehler liegt woanders.');
              openModal({
                title: this.label,
                html: '<p>Es ist kein USB-Stick eingesteckt – der Fehler bleibt bestehen.</p><p>Öffne das <b>Boot-Menü</b> oder passe die Bootreihenfolge an.</p>'
              });
            } else {
              state.usbPresent = false;
              state.s4RemovedUsb = true;
              say('<span class="good">USB entfernt.</span> Jetzt neu starten oder das <b>Boot-Menü</b> nutzen.');
              openModal({
                title: this.label,
                html: '<p>Du entfernst alle USB-Sticks. Damit stört kein externes Medium mehr.</p><p>Starte jetzt <b>neu</b> oder wähle im <b>Boot-Menü</b> die SSD.</p>'
              });
            }
          }
        },
        {
          id: 's4-restart',
          set: 'A',
          label: '🔁 Neu starten',
          hotkey: '2',
          delta: 2,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            const resolvedByUsb = !state.usbPresent;
            const resolvedByPersist = state.bootOrderPersisted;
            state.bootMenuOpen = false;
            state.activeSet = 'A';
            if(resolvedByPersist){ state.bootOrderChanged = false; }
            updateScene();
            if(resolvedByUsb || resolvedByPersist){
              state.bootError = false;
              updateScene();
              if(resolvedByUsb){
                state.s4SolvedBy = 'usb-restart';
                finish(true, 'USB-Sticks entfernt – der PC startet wieder von der SSD.');
              } else {
                state.s4SolvedBy = 'bootorder-save';
                finish(true, 'Gespeicherte Bootreihenfolge – SSD steht nun an erster Stelle.');
              }
            } else {
              setStatus('Bootfehler bleibt');
              say('<span class="warn">Noch kein Erfolg.</span> Der PC zeigt weiterhin <b>NO BOOTABLE DEVICE</b>.');
              openModal({
                title: this.label,
                html: '<p>Nach dem Neustart erscheint weiterhin <b>NO BOOTABLE DEVICE</b>.</p><p>Öffne das <b>Boot-Menü (F12)</b> oder passe die Bootreihenfolge im BIOS an.</p>'
              });
            }
          }
        },
        {
          id: 's4-monitor',
          set: 'A',
          label: '🖥️ Monitor ein/aus',
          hotkey: '3',
          delta: 1,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            state.monitorOn = !state.monitorOn;
            updateScene();
            if(state.monitorOn){
              setStatus('Monitor an');
              say('<span class="info">Monitor eingeschaltet.</span> Bild ist da – der Fehler liegt beim Booten.');
              openModal({
                title: this.label,
                html: '<p>Der Monitor ist wieder an und zeigt weiterhin <b>NO BOOTABLE DEVICE</b>.</p><p>Die Anzeige funktioniert – konzentriere dich auf Boot-Geräte.</p>'
              });
            } else {
              setStatus('Monitor aus');
              say('<span class="warn">Monitor ausgeschaltet.</span> Zum Analysieren wieder einschalten.');
              openModal({
                title: this.label,
                html: '<p>Du schaltest den Monitor aus. Für die Fehlersuche brauchst du das Bild – schalte ihn wieder ein.</p>'
              });
            }
          }
        },
        {
          id: 's4-power',
          set: 'A',
          label: '🔌 Stromkette prüfen',
          hotkey: '4',
          delta: 1,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            state.pcOn = true;
            setStatus('Strom ok');
            say('<span class="info">Stromversorgung geprüft.</span> Alles eingeschaltet – der Fehler liegt beim Booten.');
            openModal({
              title: this.label,
              html: '<p>Netzkabel und Steckdosenleiste sind in Ordnung. Der PC läuft – das Problem ist das fehlende Boot-Gerät.</p>'
            });
          }
        },
        {
          id: 's4-signal',
          set: 'A',
          label: '🔗 Monitorkabel/Quelle prüfen',
          hotkey: '5',
          delta: 1,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            state.signalOk = true;
            setStatus('Signal geprüft');
            say('<span class="info">Signal in Ordnung.</span> Anzeige passt – jetzt Boot-Reihenfolge klären.');
            openModal({
              title: this.label,
              html: '<p>Kabel und Eingang sind korrekt. Die Anzeige funktioniert – das Problem bleibt der Bootvorgang.</p>'
            });
          }
        },
        {
          id: 'boot-menu',
          set: 'A',
          label: '🧭 Boot-Menü öffnen (F12)',
          hotkey: '6',
          delta: 1,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            state.activeSet = 'B';
            state.bootMenuOpen = true;
            state.s4UsedBootMenu = true;
            setStatus('Boot-Menü geöffnet');
            updateScene();
            renderActions();
            say('<span class="info">Boot-Menü offen.</span> Wähle jetzt die SSD – das ist schnell und reversibel.');
            openModal({
              title: this.label,
              html: '<p>Du öffnest das <b>Boot-Menü</b>. Wähle die interne <b>SSD</b> als Startgerät – das wirkt sofort und ist jederzeit rückgängig.</p>'
            });
          }
        },
        {
          id: 'boot-ssd',
          set: 'B',
          label: '💽 Von SSD starten (temporär)',
          hotkey: '1',
          delta: 1,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            state.bootError = false;
            state.bootMenuOpen = false;
            state.activeSet = 'A';
            updateScene();
            renderActions();
            state.s4SolvedBy = 'temp-ssd';
            finish(true, 'Im Boot-Menü die SSD gewählt – temporärer Start gelingt sofort.');
          }
        },
        {
          id: 'boot-order',
          set: 'B',
          label: '🔀 Bootreihenfolge ansehen/ändern',
          hotkey: '2',
          delta: 2,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            state.bootOrderChanged = true;
            state.s4ChangedBootOrder = true;
            setStatus('Bootreihenfolge angepasst');
            say('<span class="info">Bootreihenfolge geändert.</span> Speichere die Änderung, damit sie bleibt.');
            openModal({
              title: this.label,
              html: '<p>Du schiebst die <b>SSD</b> an die erste Stelle. Drücke jetzt <b>Änderungen speichern</b>, sonst bleibt alles beim Alten.</p>'
            });
          }
        },
        {
          id: 'drive-check',
          set: 'B',
          label: '🧾 Laufwerke erkannt?',
          hotkey: '3',
          delta: 1,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            setStatus('Diagnose');
            say('<span class="info">SSD vorhanden.</span> Sie erscheint im BIOS – Fehler liegt an der Startreihenfolge.');
            openModal({
              title: this.label,
              html: '<p>Die interne <b>SSD</b> wird erkannt. Hardware ist ok – passe die Bootreihenfolge an oder starte direkt von der SSD.</p>'
            });
          }
        },
        {
          id: 'secure-boot',
          set: 'B',
          label: '🔒 UEFI/Secure-Boot Status ansehen',
          hotkey: '4',
          delta: 1,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            setStatus('Info');
            say('<span class="info">Nur Informationen.</span> Secure Boot ist hier nicht die Ursache.');
            openModal({
              title: this.label,
              html: '<p>Du wirfst einen Blick auf UEFI/Secure Boot. Alles unauffällig – für dieses Problem nicht nötig.</p>'
            });
          }
        },
        {
          id: 'save-changes',
          set: 'B',
          label: '💾 Änderungen speichern',
          hotkey: '5',
          delta: 2,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            if(state.bootOrderChanged){
              state.bootOrderPersisted = true;
              state.bootOrderChanged = false;
              state.bootError = false;
              state.activeSet = 'A';
              state.bootMenuOpen = false;
              updateScene();
              renderActions();
              state.s4SolvedBy = 'bootorder-save';
              finish(true, 'Bootreihenfolge gespeichert – der Neustart findet die SSD automatisch.');
            } else {
              setStatus('Keine Änderungen');
              say('<span class="warn">Nichts zu speichern.</span> Passe zuerst die Reihenfolge an.');
              openModal({
                title: this.label,
                html: '<p>Es wurden keine Änderungen vorgenommen. Verschiebe zuerst die SSD nach oben und speichere dann.</p>'
              });
            }
          }
        },
        {
          id: 'exit-nosave',
          set: 'B',
          label: '🚪 BIOS schließen (ohne Speichern)',
          hotkey: '6',
          delta: 1,
          effect(){
            state.time += this.delta; state.tries++;
            pushLog(this.label, `+${this.delta} Min`);
            state.bootMenuOpen = false;
            state.activeSet = 'A';
            state.bootOrderChanged = false;
            updateScene();
            renderActions();
            setStatus('BIOS verlassen');
            say('<span class="warn">Keine Änderungen gespeichert.</span> Der Bootfehler bleibt bestehen.');
            openModal({
              title: this.label,
              html: '<p>Du verlässt das BIOS ohne zu speichern. Der PC startet neu und zeigt wieder <b>NO BOOTABLE DEVICE</b>.</p>'
            });
          }
        }
      ];
    }
    function getActionsForLevel(levelId){
      const A = makeActions();
      if(levelId === 'L0'){
        return [A.ram, A.monitorToggle, A.bios, A.cpu, A.power, A.network];
      } else if(levelId === 'E1'){
        return [A.monitorCable, A.monitorToggle, A.bios, A.cpu, A.power, A.source];
      } else if(levelId === 'M3'){
        return [A.postCheck, A.monitorToggle, A.bios, A.ramFix, A.power, A.cmosReset];
      } else if(levelId === 'S4'){
        return makeScenario4Actions();
      } else {
        return [A.monitorToggle, A.bios, A.power, A.network, A.cpu, A.source];
      }
    }

    function loadLevel(idx){
      if(!isLevelUnlocked(idx)){
        idx = findFirstUnlockedIndex();
      }
      state.levelIdx = idx;
      // Reset core state
      state.time = 0; state.tries = 0; state.solved = false; state.log = [];
      state.performed = {};
      state.currentActionId = null;
      // Apply start flags
      const L = levels[idx];
      state.pcOn = L.start.pcOn;
      state.monitorOn = L.start.monitorOn;
      state.signalOk = L.start.signalOk;
      state.bootError = L.start.bootError ?? false;
      state.activeSet = L.start.activeSet || 'A';
      state.bootMenuOpen = !!L.start.bootMenuOpen;
      state.usbPresent = 'usbPresent' in L.start ? L.start.usbPresent : true;
      state.bootOrderChanged = !!L.start.bootOrderChanged;
      state.bootOrderPersisted = !!L.start.bootOrderPersisted;
      state.actionSequence = [];
      state.s4SolvedBy = null;
      state.s4RemovedUsb = false;
      state.s4UsedBootMenu = false;
      state.s4ChangedBootOrder = false;

      // Actions per Level
      state.actions = getActionsForLevel(L.id);

      // Wrap power action to show a dedicated "finished" message when the
      // sequence is: Button 2 (monitor) then Button 5 (power) and the
      // scenario becomes solved by turning on power.
      (function(){
        const powerAct = state.actions && state.actions.find(x => x.id === 'power-cable');
        const monitorAct = state.actions && state.actions.find(x => x.id === 'monitor');
        if(powerAct && typeof powerAct.effect === 'function'){
          const originalEffect = powerAct.effect;
          powerAct.effect = function(){
            const prevWasMonitor = !!(state.log && state.log.length && monitorAct && state.log[state.log.length-1].step === monitorAct.label);
            const willSolve = false; // old per-action wrapper check disabled
            originalEffect.call(this);
            if(willSolve){
              finish(true, 'Stromversorgung und Monitor aktiviert.');
              openModal({
                title: 'Aufgabe abgeschlossen',
                html: completionIntroHtml(),
                okLabel: 'Zurück zum Hub',
                scene: { pcOn: true, monitorOn: true, signalOk: true }
              });
            }
          };
        }
      })();

      // Also wrap monitor action: if power is already on and signal is OK,
      // turning the monitor on should complete the scenario as well.
      (function(){
        const monitorAct = state.actions && state.actions.find(x => x.id === 'monitor');
        if(monitorAct && typeof monitorAct.effect === 'function'){
          const originalEffect = monitorAct.effect;
          monitorAct.effect = function(){
            const willSolve = false; // old per-action wrapper check disabled
            originalEffect.call(this);
            if(willSolve){
              finish(true, 'Stromversorgung und Monitor aktiviert.');
              openModal({
                title: 'Aufgabe abgeschlossen',
                html: completionIntroHtml(),
                okLabel: 'Zurück zum Hub',
                scene: { pcOn: true, monitorOn: true, signalOk: true }
              });
            }
          };
        }
      })();

      renderActions();

      // UI text
      document.getElementById('storyTitle').textContent = L.storyTitle;
      document.getElementById('storyText').innerHTML = L.storyText;
      const h1 = document.getElementById('hintText1'); if(h1) h1.innerHTML = L.hints.h1;
      const h2 = document.getElementById('hintText2'); if(h2) h2.innerHTML = L.hints.h2;

      // Status
      setStatus('Unbekannt'); renderMeters();
      feedbackEl.innerHTML = 'Wähle deinen ersten Schritt.'; stepLogEl.innerHTML = '';
      summary.classList.remove('active');

      // Visuals
      updateScene();

      // Badge text
      const tag = document.getElementById('levelTag');
      if(tag){ tag.innerHTML = `Fall ${idx+1}/${levels.length} - <b>Einfach</b>`; }

      showBest();
    }

    // Clicking the badge: no-op (navigation via prev/next buttons)
    document.getElementById('levelTag').addEventListener('click', ()=>{});
    // Inject previous/next buttons around the level tag and group closely
    (function(){
      const levelTagEl = document.getElementById('levelTag');
      if(!levelTagEl || !levelTagEl.parentNode) return;
      // Wrap in a compact nav container
      const wrap = document.createElement('div');
      wrap.className = 'level-nav';
      levelTagEl.parentNode.insertBefore(wrap, levelTagEl);
      wrap.appendChild(levelTagEl);
      // Prev
      const prevBtn = document.createElement('button');
      prevBtn.className = 'btn';
      prevBtn.id = 'levelPrev';
      prevBtn.title = 'Vorheriger Fall';
      prevBtn.setAttribute('aria-label','Vorheriger Fall');
      prevBtn.textContent = '<';
      wrap.insertBefore(prevBtn, levelTagEl);
      prevBtn.addEventListener('click', ()=>{
        if(!scenarioActive) return;
        closeModal(); hideCelebration();
        const prev = findUnlockedIndex(state.levelIdx, -1);
        if(prev !== state.levelIdx) animateToLevel(prev);
      });
      // Next
      const nextBtn = document.createElement('button');
      nextBtn.className = 'btn';
      nextBtn.id = 'levelNext';
      nextBtn.title = 'Nächster Fall';
      nextBtn.setAttribute('aria-label','Nächster Fall');
      nextBtn.textContent = '>';
      wrap.appendChild(nextBtn);
      nextBtn.addEventListener('click', ()=>{
        if(!scenarioActive) return;
        closeModal(); hideCelebration();
        const next = findUnlockedIndex(state.levelIdx, 1);
        if(next !== state.levelIdx) animateToLevel(next);
      });
    })();

    // Score-Modal oeffnen
    if (document.getElementById('scoreBtn')) document.getElementById('scoreBtn').addEventListener('click', ()=>{
      const scores = loadScores();
      const items = levels.map((L, idx)=>{
        const s = scores[L.id];
        if(!s){
          return `<li><b>Fall ${idx+1}:</b> ${L.name} - <i>noch kein Ergebnis</i></li>`;
        }
        const color = s.rank === 'Gold' ? 'var(--gold)' : (s.rank === 'Silber' ? 'var(--silver)' : 'var(--bronze)');
        return `<li><b>Fall ${idx+1}:</b> ${L.name} - Zeit: <b>${s.time} Min</b>, Schritte: <b>${s.tries}</b>, Rang: <b style="color:${color}">${s.rank}</b>, Punkte: <b>${s.score}</b></li>`;
      }).join('');
      const html = `<p class="hint">Deine besten Ergebnisse pro Szenario:</p><ul class="hint">${items}</ul>`;
      openTopModal({ title: 'Score', html });
    });
    // Move footer buttons into the statusbar (right side)
    (function(){
      const statusBar = document.querySelector('.statusbar');
      const footer = document.querySelector('.footer');
      if(statusBar && footer){
        const actions = document.createElement('div');
        actions.className = 'status-actions';
        while(footer.firstChild){ actions.appendChild(footer.firstChild); }
        statusBar.appendChild(actions);
        footer.remove();
      }
    })();
    // Reveal hint
    document.getElementById('resetBtn').addEventListener('click', reset);
    if(hint1Btn){
      hint1Btn.addEventListener('click', () => {
        const bothHints = `${hint1Html}<div class="more-hints open" id="moreHints"><hr class="divider" aria-hidden="true" /><div class="hint">${hint2Html}</div></div>`;
        openModal({title:'Hinweise', html: bothHints});
      });
    }
    if(goalBtn){ goalBtn.addEventListener('click', () => openModal({title:'Ziele & LP21-Bezug', html: goalHtml})); }

    // Hotkeys 1-6 + R
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      // Neustart (R) ist immer erlaubt, selbst wenn ein Modal offen ist
      if(k==='r'){ if(scenarioActive) reset(); return; }
      // While a modal is open, allow ESC or same opener key to close, unless solved
      if(modalOpen){
        if(!state.solved){
          if(k==='escape'){
            if(topModalEl && topModalEl.classList.contains('open')) closeTopModal(); else closeModal();
            return;
          }
          if(modalOpenKey && e.key === modalOpenKey){
            if(topModalEl && topModalEl.classList.contains('open')) closeTopModal(); else closeModal();
            return;
          }
        }
        return;
      }
      if(!scenarioActive) return;
      const L = levels && levels[state.levelIdx];
      const isS4 = !!(L && L.id === 'S4');
      const activeSet = isS4 ? (state.activeSet || 'A') : null;
      const action = state.actions.find(a => a.hotkey === e.key && (!isS4 || !a.set || a.set === activeSet));
      if(action){
        // remember which key triggered the upcoming modal (if any)
        lastHotkey = e.key;
        runAction(action);
      }
    });

        // Init
    showHub();
  </script>
</body>
</html>

