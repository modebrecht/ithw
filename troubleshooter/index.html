<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PC-Troubleshooter v2.4</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">PC-Troubleshooter <span class="badge" id="verTag">v2.4</span></div>
      <div class="badge" id="levelTag" aria-live="polite">Fall 1/1 • <b>Einfach</b></div>
          <button class="btn" id="scoreBtn" title="Score anzeigen" aria-label="Score anzeigen">🏆 Score</button></header>

    <!-- Modal/Message area shown above the story -->
    <div class="action-message" id="actionMessageTop" aria-hidden="true">
      <header class="mhead">
        <h3 id="messageTitleTop">Aktion</h3>
      </header>
      <div class="mbody" id="messageBodyTop"></div>
      <div class="mfoot">
        <button class="btn primary" id="messageOkTop">Schliessen</button>
      </div>
    </div>

    <!-- Single card: story, actions & info -->
    <section class="card story" aria-labelledby="storyTitle">
      <div class="inner">
          <h2 id="storyTitle">Szenario: Der PC, der nicht starten will</h2>
          <p id="storyText">
            Du sitzt im Informatikraum und dein PC reagiert nicht: Du drückst den Power‑Knopf, aber es passiert nichts.
            Dein Ziel: In möglichst <b>wenigen Schritten</b> die Ursache finden.
          </p>

          <figure class="scene" role="img" aria-label="PC-Tower und Monitor auf einem Schreibtisch (neutrale Ausgangslage)">
            <svg viewBox="0 0 800 220" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <!-- Tischlinie -->
              <rect x="20" y="194" width="760" height="8" rx="4" class="mutfill"/>
              <rect x="20" y="194" width="760" height="8" rx="4" class="mut" fill="none"/>

              <rect x="70" y="85" width="110" height="110" rx="8" class="mut" fill="none"/>
              <circle cx="100" cy="105" r="6" class="mut led" fill="none"/>

              <!-- Monitor -->
              <rect x="240" y="12" width="270" height="160" rx="6" class="mut" fill="none"/>
              <rect x="240" y="12" width="270" height="160" rx="6" class="mutfill screen"/>
              <rect x="370" y="173" width="10" height="19" class="mut" fill="none"/>
              <rect x="335" y="190" width="80" height="6" rx="3" class="mut" fill="none"/>
              <g class="no-signal" aria-hidden="true">
                <rect x="240" y="12" width="270" height="160" rx="6" fill="none"/>
                <text x="375" y="92" font-size="24" text-anchor="middle" style="fill:rgba(229,231,235,.88);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;letter-spacing:2px">NO SIGNAL</text>
              </g>
              <g class="login" aria-hidden="true">
                <!-- Größeres, gut lesbares Login-Overlay, mittig im Monitor (270×160) -->
                <rect x="290" y="47" width="170" height="90" rx="8" class="mut" fill="none"/>
                <text x="375" y="80" font-size="32" text-anchor="middle" style="fill:rgba(229,231,235,.95);font-weight:700">Login</text>
                <rect x="310" y="96" width="130" height="12" rx="6" class="mut" fill="none"/>
                <rect x="310" y="118" width="130" height="12" rx="6" class="mut" fill="none"/>
              </g>
            </svg>
          </figure>

          <div class="statusbar" aria-live="polite">
            <div class="chip">Zeit: <strong id="time">0</strong> Min</div>
            <div class="chip">Schritte: <strong id="tries">0</strong></div>
            <div class="chip">Status: <strong id="status">Unbekannt</strong></div>
            
          </div>

          <div class="actions" id="actions" aria-label="Verfügbare Aktionen"></div>
          <div class="action-message" id="actionMessage" aria-hidden="true">
            <header class="mhead">
              <h3 id="messageTitle">Aktion</h3>
            </header>
            <div class="mbody" id="messageBody"></div>
            <div class="mfoot">
              <button class="btn primary" id="messageOk">Schliessen</button>
            </div>
          </div>
          <div class="legend" aria-hidden="true">Tasten: [1–6] Aktionen · [R] Neustart</div>

          <div class="footer">
            <button class="btn" id="resetBtn" title="Szenario zurücksetzen (R)" aria-keyshortcuts="R">Neustart</button>
            <button class="btn" id="hint1Btn">Hinweis</button>
            <button class="btn" id="goalBtn">Ziel</button>
          </div>

          <div class="feedback" aria-live="polite">
            <p class="msg" id="feedbackMsg">Wähle deinen ersten Schritt.</p>
            <ol class="step-log" id="stepLog" aria-label="Protokoll deiner Schritte"></ol>
          </div>

          <hr class="divider" aria-hidden="true" />

          <div class="summary" id="summary">
            <h3>Auswertung</h3>
            <p class="hint" id="resultText"></p>
            <div class="score">
              <span class="dot" id="rankDot" aria-hidden="true"></span>
              <span id="rankText">Bewertung: —</span>
            </div>
            <div class="hint" id="bestRow" style="display:none;margin-top:8px">Bestleistung: <b id="bestText">—</b></div>
          </div>
        </div>
    </section>
  </div>

  <script>
    // --- Persistence ---
    const STORAGE_KEY = 'pctrouble_best_v2';
    const SCORES_KEY = 'pctrouble_scores_v2';
    function loadBest(){
      try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null'); }catch{ return null; }
    }
    function saveBest(best){
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(best)); }catch{}
    }
    function loadScores(){
      try{ return JSON.parse(localStorage.getItem(SCORES_KEY) || '{}'); }catch{ return {}; }
    }
    function saveScores(scores){
      try{ localStorage.setItem(SCORES_KEY, JSON.stringify(scores)); }catch{}
    }

    // --- State ---
    const state = { levelIdx: 0, actions: [], performed: {}, currentActionId: null };

    // --- DOM helpers ---
    const $ = sel => document.querySelector(sel);
    const timeEl = $('#time');
    const triesEl = $('#tries');
    const statusEl = $('#status');
    const actionsEl = $('#actions');
    const feedbackEl = $('#feedbackMsg');
    const stepLogEl = $('#stepLog');
    const summary = $('#summary');
    const resultText = $('#resultText');
    const rankText = $('#rankText');
    const rankDot = $('#rankDot');
    const bestRow = $('#bestRow');
    const bestText = $('#bestText');
    const scoreBtn = document.getElementById('scoreBtn');
    const hint1Btn = document.getElementById('hint1Btn');
    const goalBtn = document.getElementById('goalBtn');

    const hint1Html = 'Was kannst du prüfen, <b>ohne den PC zu öffnen</b>?';
    const hint2Html = `<ul class="hint"><li><b>Stromversorgung:</b> Steckdosenleiste an? Netzkabel fest am PC und an der Leiste/Steckdose? Netzteil‑Schalter (I/O) auf <b>I</b> (falls vorhanden)?</li><li><b>Anzeige/Signal:</b> Monitor eingeschaltet? Richtigen Eingang (HDMI/DP) gewählt? Kabel steckt fest? Falls möglich, anderen Port/Kabel testen.</li><li>Wenn der PC weiterhin <i>gar nicht</i> reagiert, wären interne Ursachen der nächste Schritt – in diesem Level bleiben wir bei externen Checks.</li></ul>`;
    const goalHtml = `<ul class="hint"><li><b>Du übst:</b> strukturiert Fehler finden (erst extern, dann intern), Entscheidungen begründen und deine Schritte protokollieren.</li><li><b>LP21:</b> MI 3.3 «Fehler systematisch suchen &amp; beheben», MI 2.2 «Geräte zweckmässig einsetzen» — genau das trainierst du hier im Szenario.</li><li><b>Tipps fürs Szenario:</b> formuliere deine Vermutung laut, notiere jeden Schritt (Zeit/Schritte siehst du links) und vergleiche danach mit deiner Bestleistung.</li></ul>`;

    // Message helpers
    let modalOpen = false, lastFocusEl = null;
    // Default in-card modal for actions/hints
    const modalEl = document.getElementById('actionMessage');
    const modalTitleEl = document.getElementById('messageTitle');
    const modalBodyEl = document.getElementById('messageBody');
    const modalOkEl = document.getElementById('messageOk');
    // Top score modal elements (only used for Score)
    const topModalEl = document.getElementById('actionMessageTop');
    const topModalTitleEl = document.getElementById('messageTitleTop');
    const topModalBodyEl = document.getElementById('messageBodyTop');
    const topModalOkEl = document.getElementById('messageOkTop');
    let celebrationEl = null;
    let celebrationTimer = null;
    // Track which hotkey opened the modal (if any)
    let lastHotkey = null;
    let modalOpenKey = null;
    function openModal({title='Hinweis', html='', okLabel='Schliessen'}){
      if(!modalEl) return;
      modalOpen = true;
      actionsEl.style.display = 'none';
      modalTitleEl.textContent = title;
      // Inject Auswertung into the completion modal
      if(title === 'Aufgabe abgeschlossen'){
        modalEl.classList.add('completion');
        // Show evaluation; completion must be triggered explicitly elsewhere
        const evalHtml = typeof buildEvaluationHtml === 'function' ? buildEvaluationHtml() : '';
        const intro = (typeof completionIntroHtml === 'function') ? completionIntroHtml() : html;
        modalBodyEl.innerHTML = intro + evalHtml;
      } else {
        modalBodyEl.innerHTML = html;
        modalEl.classList.remove('completion');
      }
      if(modalOkEl) modalOkEl.textContent = okLabel;
      if(title === 'Aufgabe abgeschlossen' && modalOkEl){ modalOkEl.textContent = 'Nächste Aufgabe'; }
      modalEl.classList.add('open');
      modalEl.setAttribute('aria-hidden','false');
      lastFocusEl = document.activeElement;
      if(modalOkEl) modalOkEl.focus();
      // remember the key that opened this modal and reset the pending one
      modalOpenKey = lastHotkey;
      lastHotkey = null;
      if(title === 'Aufgabe abgeschlossen') showCelebration();
    }
    function openTopModal({title='Score', html='', okLabel='Schliessen'}){
      if(!topModalEl) return;
      modalOpen = true;
      actionsEl.style.display = 'none';
      if(topModalTitleEl) topModalTitleEl.textContent = title;
      if(topModalBodyEl) topModalBodyEl.innerHTML = html;
      if(topModalOkEl) topModalOkEl.textContent = okLabel;
      topModalEl.classList.add('open');
      topModalEl.setAttribute('aria-hidden','false');
      lastFocusEl = document.activeElement;
      if(topModalOkEl) topModalOkEl.focus();
      modalOpenKey = lastHotkey;
      lastHotkey = null;
    }
    function closeModal(){
      if(!modalEl) return;
      modalOpen = false;
      modalEl.classList.remove('open');
      modalEl.classList.remove('completion');
      modalEl.setAttribute('aria-hidden','true');
      actionsEl.style.display = '';
      if(lastFocusEl) lastFocusEl.focus();
      hideCelebration();
      modalOpenKey = null;
    }
    function closeTopModal(){
      if(!topModalEl) return;
      modalOpen = false;
      topModalEl.classList.remove('open');
      topModalEl.setAttribute('aria-hidden','true');
      actionsEl.style.display = '';
      if(lastFocusEl) lastFocusEl.focus();
      modalOpenKey = null;
    }
    function showCelebration(){
      if(celebrationEl) return;
      if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches){ return; }
      celebrationEl = document.createElement('div');
      celebrationEl.className = 'confetti';
      const colors = ['#fbbf24','#60a5fa','#22c55e','#ef4444'];
      function spawn(n=12){
        for(let i=0;i<n;i++){
          const p = document.createElement('span');
          p.className = 'confetti-piece';
          p.style.left = Math.random()*100 + '%';
          p.style.backgroundColor = colors[i % colors.length];
          p.style.animationDelay = (Math.random()*0.8) + 's';
          p.style.animationDuration = (2 + Math.random()*2) + 's';
          p.addEventListener('animationend', ()=> p.remove());
          celebrationEl.appendChild(p);
        }
      }
      spawn(24);
      document.body.appendChild(celebrationEl);
      celebrationTimer = setInterval(()=> spawn(10), 600);
    }
    function hideCelebration(){
      if(celebrationTimer){ clearInterval(celebrationTimer); celebrationTimer = null; }
      if(celebrationEl){ celebrationEl.remove(); celebrationEl = null; }
    }
    // Transition helper: animate card out/in when switching levels
    function animateToLevel(idx){
      const card = document.querySelector('section.card.story');
      if(!card){ loadLevel(idx); return; }
      // If already animating, skip to direct load
      if(card.classList.contains('transition-out') || card.classList.contains('transition-in')){
        loadLevel(idx); return;
      }
      card.classList.add('transitioning','transition-out');
      const onOutEnd = ()=>{
        card.removeEventListener('animationend', onOutEnd);
        loadLevel(idx);
        // Next tick to ensure DOM updates before animating in
        requestAnimationFrame(()=>{
          card.classList.remove('transition-out');
          card.classList.add('transition-in');
          const onInEnd = ()=>{
            card.removeEventListener('animationend', onInEnd);
            card.classList.remove('transition-in','transitioning');
          };
          card.addEventListener('animationend', onInEnd, { once:true });
        });
      };
      card.addEventListener('animationend', onOutEnd, { once:true });
    }

    if(modalOkEl) modalOkEl.addEventListener('click', () => {
      // If success modal, advance to next scenario with animation
      if(modalTitleEl && modalTitleEl.textContent === 'Aufgabe abgeschlossen'){
        const next = (state.levelIdx + 1) % levels.length;
        closeModal(); hideCelebration();
        animateToLevel(next);
      } else {
        closeModal();
      }
    });
    if(topModalOkEl) topModalOkEl.addEventListener('click', () => { closeTopModal(); });

    function setStatus(txt){ statusEl.textContent = txt; renderMeters(); }
    function renderMeters(){ timeEl.textContent = state.time; triesEl.textContent = state.tries; }
    function say(html){ feedbackEl.innerHTML = html; }
    function pushLog(step, note=''){
      state.log.push({step, note});
      const li = document.createElement('li');
      li.textContent = note ? `${step} (${note})` : step;
      stepLogEl.appendChild(li);
    }

    function runAction(a){
      if(!a) return;
      state.currentActionId = a.id || null;
      a.effect.call(a);
      if(a.id){ state.performed[a.id] = true; }
      // If the action itself solved the scenario (e.g., Scenario 2),
      // immediately show the completion modal like Scenario 1.
      if(state.solved && !modalOpen){
        openModal({
          title: 'Aufgabe abgeschlossen',
          html: completionIntroHtml(),
          okLabel: 'Nächste Aufgabe'
        });
        return;
      }
      if(checkSolvedPerScenario && checkSolvedPerScenario()) return;
      const solvedCombo = false; // old combo check disabled
        // old condition removed
        // old condition removed
        // old condition removed
      if(false){ // old combo check disabled
        finish(true, 'Stromversorgung und Monitor aktiviert.');
        openModal({
          title: 'Aufgabe abgeschlossen',
          html: completionIntroHtml(),
          okLabel: 'Nächste Aufgabe'
        });
      } else if (!modalOpen){
        const html = (feedbackEl && feedbackEl.innerHTML) ? feedbackEl.innerHTML : 'Aktion ausgeführt.';
        openModal({
          title: a.label,
          html
        });
      }
    }

    function checkSolvedPerScenario(){
      const L = levels && levels[state.levelIdx];
      if(!L) return false;
      switch(L.id){
        case 'L0': {
          const hasMonitor = !!state.performed['monitor'];
          const hasPower = !!state.performed['power-cable'];
          if(!state.solved && hasMonitor && hasPower && state.monitorOn){
            finish(true, 'Stromversorgung und Monitor aktiviert.');
            openModal({ title: 'Aufgabe abgeschlossen', html: completionIntroHtml(), okLabel: 'N��chste Aufgabe' });
            return true;
          }
          break;
        }
        case 'E1': {
          // Require order: first [2] monitor on, then [6] source
          const didMonitor = !!state.performed['monitor'];
          const isSourceNow = state.currentActionId === 'source';
          if(!state.solved && didMonitor && isSourceNow && state.monitorOn){
            finish(true, 'Quelle korrekt, Signal wiederhergestellt.');
            openModal({ title: 'Aufgabe abgeschlossen', html: completionIntroHtml(), okLabel: 'N��chste Aufgabe' });
            return true;
          }
          break;
        }
        default:
          break;
      }
      return false;
    }

    function updateScene(){
      const scene = document.querySelector('.scene');
      if(!scene) return;
      scene.classList.remove('nosig','power-on','login');
      if(state.pcOn) scene.classList.add('power-on');
      if(state.monitorOn && (!state.pcOn || !state.signalOk)) scene.classList.add('nosig');
      if(state.pcOn && state.monitorOn && state.signalOk) scene.classList.add('login');
    }

    function renderActions(){
      actionsEl.innerHTML = '';
      [...state.actions]
        .sort((a,b)=>parseInt(a.hotkey)-parseInt(b.hotkey))
        .forEach(a=>{
          const btn = document.createElement('button');
          btn.className = 'action';
          btn.type = 'button';
          btn.dataset.key = a.hotkey;
          btn.innerHTML = `<span class="label">${a.label}</span>`;
          btn.setAttribute('aria-label', a.label + ` Taste ${a.hotkey}`);
          btn.addEventListener('click', () => { lastHotkey = a.hotkey; runAction(a); });
          actionsEl.appendChild(btn);
        });
    }

    
    function evalRankAndScore(t, n){
  var medal = 'Bronze';
  var long = 'Bronze - geloest, aber umstaendlich';
  var color = 'var(--bronze)';
  if (t <= 3 && n <= 2){ medal = 'Gold'; long = 'Gold - exzellent (praezise & schnell)'; color = 'var(--gold)'; }
  else if (t <= 6 && n <= 3){ medal = 'Silber'; long = 'Silber - gut & systematisch'; color = 'var(--silver)'; }
  var score = medal === 'Gold' ? 100 : (medal === 'Silber' ? 70 : 40);
  return { medal: medal, long: long, color: color, score: score };
}
function buildEvaluationHtml(){
      const t = state.time;
      const n = state.tries;
      const ev = evalRankAndScore(t, n);
      const best = loadBest();
      const bestHtml = best ? `<div class="hint" style="margin-top:8px">Bestleistung: <b>${best.time} Min / ${best.tries} Schritte</b></div>` : '';
      const dotStyle = `background: linear-gradient(180deg, ${ev.color}, ${ev.color})`;
      return `
        <hr class="divider" aria-hidden="true" />
        <h3>AUSWERTUNG</h3>
        <p class="hint">Zeit: <b>${t} Min</b> - Schritte: <b>${n}</b> - Punkte: <b>${ev.score}</b></p>
        <div class="score">
          <span class="dot" style="${dotStyle}" aria-hidden="true"></span>
          <span>Bewertung: ${ev.long}</span>
        </div>
        ${bestHtml}
      `;
}
function completionIntroHtml(){
  const L = levels && levels[state.levelIdx];
  if(!L) return '<p><b>Aufgabe geschafft.</b> PC und Monitor sind bereit.</p><p>Das <b>Login</b> ist sichtbar.</p>';
  switch(L.id){
    case 'L0':
      return '<p><b>Aufgabe abgeschlossen.</b> PC hat Strom, Monitor ist an, Signal liegt an.</p><p>Das <b>Login</b> ist sichtbar.</p>';
    case 'E1':
      return '<p><b>Aufgabe abgeschlossen.</b> Quelle korrekt, Signal wiederhergestellt.</p><p>Das <b>Login</b> ist sichtbar.</p>';
    case 'M3':
      return '<p><b>Aufgabe abgeschlossen.</b> POST erfolgreich, Anzeige aktiv.</p><p>Das <b>Login</b> ist sichtbar.</p>';
    default:
      return '<p><b>Aufgabe geschafft.</b> PC und Monitor sind bereit.</p><p>Das <b>Login</b> ist sichtbar.</p>';
  }
}
function finish(success, detail){
      // Scenario-specific guard: E1 requires order 2 then 6
      try{
        const L = levels && levels[state.levelIdx];
        if(L && L.id === 'E1'){
          const isSourceNow = state.currentActionId === 'source';
          const didMonitor = !!(state.performed && state.performed['monitor']);
          if(!(isSourceNow && didMonitor && state.monitorOn)){
            return; // block auto-finish if order not satisfied
          }
        }
      }catch(e){}
      state.solved = true;
      showCelebration();
      setStatus('Geloest');
      say(`<span class="good">Problem behoben.</span> ${detail} Der PC startet, du kannst weiterarbeiten.`);
      // Hinweis: Reset bleibt jederzeit möglich

      // Bewertung
      const t = state.time;
      const n = state.tries;
      const ev = evalRankAndScore(t, n);
      resultText.innerHTML = 'Zeit: <b>' + t + ' Min</b> - Schritte: <b>' + n + '</b> - Punkte: <b>' + ev.score + '</b>'; 
      rankText.textContent = 'Bewertung: ' + ev.long; 
      rankDot.style.background = 'linear-gradient(180deg, ' + ev.color + ', ' + ev.color + ')'; 

      // Bestleistung speichern/anzeigen (besser = weniger Zeit, bei Gleichstand weniger Schritte)
      const prev = loadBest();
      const current = {time:t, tries:n};
      const better = !prev || current.time < prev.time || (current.time === prev.time && current.tries < prev.tries);
      if (better){ saveBest(current); }
      showBest();
      // Pro-Szenario-Score speichern
      const L = levels[state.levelIdx];
      const scores = loadScores();
      const prevS = scores[L.id];
      const shouldUpdate = !prevS || (ev.score > prevS.score) || (ev.score === prevS.score && (t < prevS.time || (t === prevS.time && n < prevS.tries)));
      if (shouldUpdate){
        scores[L.id] = { time: t, tries: n, rank: ev.medal, score: ev.score, updatedAt: new Date().toISOString() };
        saveScores(scores);
      }
    }

    function animateReset(){
      try{ if(topModalEl && topModalEl.classList.contains('open')) closeTopModal(); }catch(e){}
      try{ if(modalOpen) closeModal(); }catch(e){}
      try{ hideCelebration(); }catch(e){}
      const card = document.querySelector('section.card.story');
      if(!card){ loadLevel(state.levelIdx); return; }
      if(card.classList.contains('restart-out') || card.classList.contains('restart-in')){ loadLevel(state.levelIdx); return; }
      // Overlay hint
      let ov = document.createElement('div');
      ov.className = 'restart-overlay';
      ov.innerHTML = '<div class="restart-indicator"><span class="icon">⟳</span><span>Neustart</span></div>';
      document.body.appendChild(ov);
      card.classList.add('transitioning','restart-out');
      const onOutEnd = ()=>{
        card.removeEventListener('animationend', onOutEnd);
        loadLevel(state.levelIdx);
        requestAnimationFrame(()=>{
          card.classList.remove('restart-out');
          card.classList.add('restart-in');
          const onInEnd = ()=>{
            card.removeEventListener('animationend', onInEnd);
            card.classList.remove('restart-in','transitioning');
            // remove overlay after a short delay
            setTimeout(()=>{ try{ ov.remove(); }catch(e){} }, 200);
          };
          card.addEventListener('animationend', onInEnd, { once:true });
        });
      };
      card.addEventListener('animationend', onOutEnd, { once:true });
    }

    function reset(){ animateReset(); }

    function showBest(){
      const best = loadBest();
      if(best){
        if(bestText) bestText.textContent = `${best.time} Min / ${best.tries} Schritte`;
        if(bestRow) bestRow.style.display = '';
      } else {
        if(bestRow) bestRow.style.display = 'none';
      }
    }

    // Level definitions & loader
    const levels = [
      {
        id: 'L0',
        name: 'Der PC startet nicht',
        storyTitle: 'Szenario: Der PC, der nicht starten will',
        storyText: 'Du sitzt im Informatikraum und dein PC reagiert nicht: Du drückst den Power‑Knopf, aber es passiert nichts. Dein Ziel: In möglichst <b>wenigen Schritten</b> die Ursache finden.',
        hints: {
          h1: 'Was kannst du prüfen, <b>ohne den PC zu öffnen</b>?',
          h2: '<ul class="hint"><li><b>Stromversorgung:</b> Kabel/Leiste/Netzschalter prüfen.</li><li><b>Anzeige:</b> Monitor einschalten / richtigen Eingang wählen.</li></ul>'
        },
        start: { pcOn: false, monitorOn: false, signalOk: true }
      },
      {
        id: 'E1',
        name: 'No Signal (falsche Quelle)',
        storyTitle: 'Szenario: PC läuft, kein Bild',
        storyText: 'Der PC läuft (Lüfter/LED), aber wir haben kein Bild. <b>Was überprüfst du als Erstes?</b>',
        hints: {
          h1: 'Was beeinflusst das <b>Bild</b>, ohne den PC zu öffnen?',
          h2: '<ul class="hint"><li><b>Anzeige:</b> Monitor einschalten.</li><li><b>Quelle/Kabel:</b> HDMI/DP richtig wählen oder Kabel fest einstecken.</li></ul>'
        },
        start: { pcOn: true, monitorOn: false, signalOk: false }
      },
      {
        id: 'M3',
        name: 'Kein Bild trotz Start (POST)',
        storyTitle: 'Szenario: Kein Bild trotz Start',
        storyText: 'Der PC läuft (Lüfter/LED), der Monitor ist an – doch es erscheint <i>kein Bild</i> (No Signal). <b>Was prüfst du als Nächstes?</b>',
        hints: {
          h1: 'Vor dem Bild passiert der <b>POST</b>. Was verraten <b>Pieptöne/LEDs</b>?',
          h2: '<ul class="hint"><li><b>POST-Hinweise lesen:</b> DRAM-LED an? Beepcode für Speicher?</li><li><b>RAM prüfen:</b> Riegel korrekt eindrücken/einzeln testen.</li><li><b>Anzeige nur sekundär:</b> Monitor kann an sein, aber ohne POST gibt es kein Signal.</li></ul>'
        },
        start: { pcOn: true, monitorOn: true, signalOk: false }
      }
    ];

    function makeActions(){
      return {
        // L0-only
        ram: {
          id: 'ram',
          label: '📏 Arbeitsspeicher überprüfen',
          hotkey: '1',
          delta: 6,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Intern - nicht zielfuehrend');
            pushLog(this.label, `+${this.delta} Min`);
            say('<span class="bad">Overkill / nicht symptombezogen.</span> Bei "geht nicht an" zuerst externe Checks (Strom, Monitor).');
          }
        },
        network: {
          id: 'network',
          label: '🌐 Netzwerkkabel prüfen',
          hotkey: '6',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Nicht relevant');
            pushLog(this.label, '+1 Min');
            say('<span class="warn">Kein Einfluss aufs Einschalten.</span> Nützlich bei Internet-/Anmeldeproblemen. Hier zuerst <b>Strom</b> und <b>Monitor</b> klären.');
          }
        },
        // Shared
        monitorToggle: {
          id: 'monitor',
          label: '🖥️ Monitor ein/aus',
          hotkey: '2',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            if(state.monitorOn){
              state.monitorOn = false; updateScene();
              setStatus('Monitor aus');
              pushLog(this.label, '+1 Min');
              say('<span class="warn">Monitor ausgeschaltet.</span> Schalte ihn wieder ein, wenn du bereit bist, und prüfe <b>Quelle/Kabel</b>.');
              openModal({
                title: 'Monitor ausgeschaltet',
                html: '<p>Du schaltest den Monitor aus. Das Display bleibt schwarz.</p><p>Schalte ihn wieder ein, um die Anzeige zu prüfen.</p>'
              });
            } else {
              state.monitorOn = true; updateScene();
              setStatus('Monitor an');
              pushLog(this.label, '+1 Min');
              if(state.pcOn && state.signalOk){
                say('<span class="good">Monitor eingeschaltet.</span> <b>Login</b> ist sichtbar.');
                openModal({
                  title: 'Bild vorhanden',
                  html: '<p>Der Monitor ist an und zeigt <b>Login</b>.</p><p>Gut gemacht!</p>'
                });
              } else {
                say('<span class="warn">Monitor ist an.</span> Anzeige zeigt <b>NO SIGNAL</b>. Prüfe <b>Quelle (HDMI/DP)</b> oder <b>Monitorkabel</b>.');
                openModal({
                  title: 'Monitor eingeschaltet',
                  html: '<p>Der Monitor ist an.</p><p>Es wird <b>NO SIGNAL</b> angezeigt – prüfe <b>Quelle/Kabel</b>.</p>'
                });
              }
            }
          }
        },
        bios: {
          id: 'bios',
          label: '⚙️ Direkt ins BIOS starten',
          hotkey: '3',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Nicht zielfuehrend');
            pushLog(this.label, '+1 Min');
            if(!state.pcOn){
              say(`<span class="bad">Das geht (noch) nicht.</span> Solange der PC <i>gar nicht</i> startet, kommst du nicht ins BIOS. Erst muss <b>Strom</b> anliegen.`);
            } else {
              say(`<span class="warn">Nicht zielführend.</span> Das Problem betrifft <b>Anzeige/Signal</b>, nicht das BIOS. Prüfe Monitor <b>ein/aus</b>, <b>Quelle</b> oder <b>Kabel</b>.`);
            }
          }
        },
        cpu: {
          id: 'cpu',
          label: '🧰 Prozessor ausbauen & neu einsetzen',
          hotkey: '4',
          delta: 8,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Risiko hoch');
            pushLog(this.label, '+8 Min');
            say(`<span class="bad">Overkill!</span> Das ist ein tiefer Eingriff mit Risiko. Zuerst immer die <b>einfachen</b> Dinge prüfen: Strom, Kabel, Schalter.`);
          }
        },
        power: {
          id: 'power-cable',
          label: '🔌 Stromkabel & Steckdose prüfen',
          hotkey: '5',
          delta: 2,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            const wasOn = state.pcOn;
            setStatus('Strom ok');
            pushLog(this.label, `+${this.delta} Min`);
            state.pcOn = true;
            updateScene();
            const html = wasOn
              ? '<p>Du prüfst die Stromkette – sie war bereits <b>in Ordnung</b>. Der PC hat Strom.</p><p>Falls noch kein Bild zu sehen ist: <b>Monitor einschalten</b> oder <b>Signal prüfen</b>.</p>'
              : '<p>Du verfolgst das Netzkabel bis zur Steckdose. Am Netzteil war das Kabel <b>locker</b> – du steckst es fest ein. Die PC‑LED leuchtet jetzt <b>grün</b>.</p><p>Der Monitor bleibt noch schwarz. Überlege: <b>Monitor einschalten</b> oder <b>Signal prüfen</b>?</p>';
            openModal({ title: 'Stromkette geprüft', html });
            if(state.monitorOn && state.signalOk){
              say('<span class="good">Stromversorgung hergestellt.</span> <b>Login</b> ist sichtbar.');
            } else {
              say('<span class="good">Stromversorgung hergestellt.</span> Prüfe nun die <b>Anzeige/Signal</b> (Monitor einschalten / Quelle wählen).');
            }
          }
        },
        monitorCable: {
          id: 'monitor-cable',
          label: '🔌 Monitorkabel prüfen',
          hotkey: '1',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Signal pruefen');
            pushLog(this.label, '+1 Min');
            // Szenario 2 (E1): Kabel war bereits korrekt eingesteckt -> keine Aenderung
            const cur = levels && levels[state.levelIdx];
            if(cur && cur.id === 'E1'){
              say('<span class="info">Kabel war bereits <b>korrekt eingesteckt</b>.</span> Pruefe jetzt die <b>Quelle (HDMI/DP)</b>.');
              return;
            }
            state.signalOk = true; updateScene();
            const L = levels && levels[state.levelIdx];
            if(state.pcOn && state.monitorOn){
              say('<span class="good">Kabel sitzt fest.</span> <b>Login</b> ist sichtbar.');
              if(!L || L.id !== 'E1'){
                finish(true, 'Signal wiederhergestellt.');
              }
            } else if(!state.monitorOn){
              say('<span class="warn">Kabel sitzt fest.</span> Schalte jetzt den <b>Monitor</b> ein.');
            } else {
              say('<span class="warn">Kabel sitzt fest.</span> Prüfe noch die <b>Stromversorgung</b> des PCs.');
            }
          }
        },
        source: {
          id: 'source',
          label: '🔀 Monitorquelle umschalten (HDMI/DP)',
          hotkey: '6',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Signal pruefen');
            pushLog(this.label, '+1 Min');
            // Wenn der Monitor AUS ist, kann die Quelle nicht umgeschaltet werden → erst einschalten
            if(!state.monitorOn){
              say('<span class="warn">Monitor ist aus.</span> Schalte zuerst den <b>Monitor</b> ein, dann die <b>Quelle</b> wählen.');
              return;
            }
            // Quelle korrekt → Signal ok (nur wenn Monitor an)
            state.signalOk = true; updateScene();
            if(state.pcOn){
              say('<span class="good">Quelle korrekt.</span> <b>Login</b> ist sichtbar.');
              finish(true, 'Signal wiederhergestellt.');
            } else {
              say('<span class="warn">Quelle korrekt.</span> Prüfe noch die <b>Stromversorgung</b> des PCs.');
            }
          }
        },
        ramFix: {
          id: 'ram-fix',
          label: '📏 Arbeitsspeicher (RAM) überprüfen',
          hotkey: '4',
          delta: 4,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('POST ok');
            pushLog(this.label, '+4 Min');
            state.signalOk = true; updateScene();
            if(state.pcOn && state.monitorOn){
              say('<span class="good">Arbeitsspeicher sitzt korrekt.</span> <b>Login</b> ist sichtbar.');
              finish(true, 'POST erfolgreich, Anzeige aktiv.');
            } else if(!state.monitorOn){
              say('<span class="warn">Arbeitsspeicher sitzt korrekt.</span> Schalte jetzt den <b>Monitor</b> ein.');
            } else {
              say('<span class="warn">Arbeitsspeicher sitzt korrekt.</span> Prüfe noch die <b>Stromversorgung</b>.');
            }
          }
        },
        postCheck: {
          id: 'post-check',
          label: '🔔 Pieptöne / POST‑LED prüfen',
          hotkey: '1',
          delta: 1,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Diagnose');
            pushLog(this.label, '+1 Min');
            say('<span class="good">Hinweis:</span> Die <b>DRAM‑LED</b> leuchtet / Beepcode für Speicher. <b>Arbeitsspeicher (RAM) prüfen<\/b> (korrekt einsetzen).');
          }
        },
        cmosReset: {
          id: 'cmos-reset',
          label: '🪛 CMOS‑Reset (kurz)',
          hotkey: '6',
          delta: 2,
          effect(){
            if(state.solved) return;
            state.time += this.delta; state.tries++;
            setStatus('Nicht zielfuehrend');
            pushLog(this.label, '+2 Min');
            say('<span class="warn">Hier unwahrscheinlich.</span> CMOS‑Reset hilft bei BIOS‑Fehlkonfig. Der Hinweis zeigt eher auf <b>RAM</b> (POST).');
          }
        }
      };
    }
    function getActionsForLevel(levelId){
      const A = makeActions();
      if(levelId === 'L0'){
        return [A.ram, A.monitorToggle, A.bios, A.cpu, A.power, A.network];
      } else if(levelId === 'E1'){
        return [A.monitorCable, A.monitorToggle, A.bios, A.cpu, A.power, A.source];
      } else if(levelId === 'M3'){
        return [A.postCheck, A.monitorToggle, A.bios, A.ramFix, A.power, A.cmosReset];
      } else {
        return [A.monitorToggle, A.bios, A.power, A.network, A.cpu, A.source];
      }
    }

    function loadLevel(idx){
      state.levelIdx = idx;
      // Reset core state
      state.time = 0; state.tries = 0; state.solved = false; state.log = [];
      state.performed = {};
      state.currentActionId = null;
      // Apply start flags
      const L = levels[idx];
      state.pcOn = L.start.pcOn;
      state.monitorOn = L.start.monitorOn;
      state.signalOk = L.start.signalOk;

      // Actions per Level
      state.actions = getActionsForLevel(L.id);

      // Wrap power action to show a dedicated "finished" message when the
      // sequence is: Button 2 (monitor) then Button 5 (power) and the
      // scenario becomes solved by turning on power.
      (function(){
        const powerAct = state.actions && state.actions.find(x => x.id === 'power-cable');
        const monitorAct = state.actions && state.actions.find(x => x.id === 'monitor');
        if(powerAct && typeof powerAct.effect === 'function'){
          const originalEffect = powerAct.effect;
          powerAct.effect = function(){
            const prevWasMonitor = !!(state.log && state.log.length && monitorAct && state.log[state.log.length-1].step === monitorAct.label);
            const willSolve = false; // old per-action wrapper check disabled
            originalEffect.call(this);
            if(willSolve){
              finish(true, 'Stromversorgung und Monitor aktiviert.');
              openModal({
                title: 'Aufgabe abgeschlossen',
                html: completionIntroHtml(),
                okLabel: 'Nächste Aufgabe',
                scene: { pcOn: true, monitorOn: true, signalOk: true }
              });
            }
          };
        }
      })();

      // Also wrap monitor action: if power is already on and signal is OK,
      // turning the monitor on should complete the scenario as well.
      (function(){
        const monitorAct = state.actions && state.actions.find(x => x.id === 'monitor');
        if(monitorAct && typeof monitorAct.effect === 'function'){
          const originalEffect = monitorAct.effect;
          monitorAct.effect = function(){
            const willSolve = false; // old per-action wrapper check disabled
            originalEffect.call(this);
            if(willSolve){
              finish(true, 'Stromversorgung und Monitor aktiviert.');
              openModal({
                title: 'Aufgabe abgeschlossen',
                html: completionIntroHtml(),
                okLabel: 'Nächste Aufgabe',
                scene: { pcOn: true, monitorOn: true, signalOk: true }
              });
            }
          };
        }
      })();

      renderActions();

      // UI text
      document.getElementById('storyTitle').textContent = L.storyTitle;
      document.getElementById('storyText').innerHTML = L.storyText;
      const h1 = document.getElementById('hintText1'); if(h1) h1.innerHTML = L.hints.h1;
      const h2 = document.getElementById('hintText2'); if(h2) h2.innerHTML = L.hints.h2;

      // Status
      setStatus('Unbekannt'); renderMeters();
      feedbackEl.innerHTML = 'Wähle deinen ersten Schritt.'; stepLogEl.innerHTML = '';
      summary.classList.remove('active');

      // Visuals
      updateScene();

      // Badge text
      const tag = document.getElementById('levelTag');
      if(tag){ tag.innerHTML = `Fall ${idx+1}/${levels.length} - <b>Einfach</b>`; }
    }

    // Clicking the badge: no-op (navigation via prev/next buttons)
    document.getElementById('levelTag').addEventListener('click', ()=>{});
    // Inject previous/next buttons around the level tag and group closely
    (function(){
      const levelTagEl = document.getElementById('levelTag');
      if(!levelTagEl || !levelTagEl.parentNode) return;
      // Wrap in a compact nav container
      const wrap = document.createElement('div');
      wrap.className = 'level-nav';
      levelTagEl.parentNode.insertBefore(wrap, levelTagEl);
      wrap.appendChild(levelTagEl);
      // Prev
      const prevBtn = document.createElement('button');
      prevBtn.className = 'btn';
      prevBtn.id = 'levelPrev';
      prevBtn.title = 'Vorheriger Fall';
      prevBtn.setAttribute('aria-label','Vorheriger Fall');
      prevBtn.textContent = '<';
      wrap.insertBefore(prevBtn, levelTagEl);
      prevBtn.addEventListener('click', ()=>{
        closeModal(); hideCelebration();
        const prev = (state.levelIdx - 1 + levels.length) % levels.length;
        animateToLevel(prev);
      });
      // Next
      const nextBtn = document.createElement('button');
      nextBtn.className = 'btn';
      nextBtn.id = 'levelNext';
      nextBtn.title = 'Nächster Fall';
      nextBtn.setAttribute('aria-label','Nächster Fall');
      nextBtn.textContent = '>';
      wrap.appendChild(nextBtn);
      nextBtn.addEventListener('click', ()=>{
        closeModal(); hideCelebration();
        const next = (state.levelIdx + 1) % levels.length;
        animateToLevel(next);
      });
    })();

    // Score-Modal oeffnen
    if (document.getElementById('scoreBtn')) document.getElementById('scoreBtn').addEventListener('click', ()=>{
      const scores = loadScores();
      const items = levels.map((L, idx)=>{
        const s = scores[L.id];
        if(!s){
          return `<li><b>Fall ${idx+1}:</b> ${L.name} - <i>noch kein Ergebnis</i></li>`;
        }
        const color = s.rank === 'Gold' ? 'var(--gold)' : (s.rank === 'Silber' ? 'var(--silver)' : 'var(--bronze)');
        return `<li><b>Fall ${idx+1}:</b> ${L.name} - Zeit: <b>${s.time} Min</b>, Schritte: <b>${s.tries}</b>, Rang: <b style="color:${color}">${s.rank}</b>, Punkte: <b>${s.score}</b></li>`;
      }).join('');
      const html = `<p class="hint">Deine besten Ergebnisse pro Szenario:</p><ul class="hint">${items}</ul>`;
      openTopModal({ title: 'Score', html });
    });
    // Move footer buttons into the statusbar (right side)
    (function(){
      const statusBar = document.querySelector('.statusbar');
      const footer = document.querySelector('.footer');
      if(statusBar && footer){
        const actions = document.createElement('div');
        actions.className = 'status-actions';
        while(footer.firstChild){ actions.appendChild(footer.firstChild); }
        statusBar.appendChild(actions);
        footer.remove();
      }
    })();
    // Reveal hint
    document.getElementById('resetBtn').addEventListener('click', reset);
    if(hint1Btn){
      hint1Btn.addEventListener('click', () => {
        const bothHints = `${hint1Html}<div class="more-hints open" id="moreHints"><hr class="divider" aria-hidden="true" /><div class="hint">${hint2Html}</div></div>`;
        openModal({title:'Hinweise', html: bothHints});
      });
    }
    if(goalBtn){ goalBtn.addEventListener('click', () => openModal({title:'Ziele & LP21-Bezug', html: goalHtml})); }

    // Hotkeys 1-6 + R
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      // Neustart (R) ist immer erlaubt, selbst wenn ein Modal offen ist
      if(k==='r'){ reset(); return; }
      // While a modal is open, allow ESC or same opener key to close, unless solved
      if(modalOpen){
        if(!state.solved){
          if(k==='escape'){
            if(topModalEl && topModalEl.classList.contains('open')) closeTopModal(); else closeModal();
            return;
          }
          if(modalOpenKey && e.key === modalOpenKey){
            if(topModalEl && topModalEl.classList.contains('open')) closeTopModal(); else closeModal();
            return;
          }
        }
        return;
      }
      const action = state.actions.find(a => a.hotkey === e.key);
      if(action){
        // remember which key triggered the upcoming modal (if any)
        lastHotkey = e.key;
        runAction(action);
      }
    });

        // Init
    loadLevel(0);
    showBest();
  </script>
</body>
</html>

